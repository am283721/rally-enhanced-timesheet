<!DOCTYPE html>
<html>
<head>
    <title>Rally Enhanced Timesheet</title>
    <!--  Build Date: Sat Jan 21 2023 14:25:19 GMT+0100 (Central European Standard Time) -->
    <!--  Version: "0.1.3"-->
    <!--  Repository: "https:/github.com/am283721/rally-enhanced-timesheet"-->
    <script type="text/javascript" src="/apps/2.1/sdk-debug.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('TSUtilities', {
  singleton: true,

  timeLockKeyPrefix: 'rally.technicalservices.timesheet.weeklock',
  approvalKeyPrefix: 'rally.technicalservices.timesheet.status',
  deletionKeyPrefix: 'rally.technicalservices.timesheet.deletion',
  pinKeyPrefix: 'rally.technicalservices.timesheet.pin',

  archiveSuffix: '~archived',

  loadWsapiRecords: function (config, returnOperation) {
    let deferred = Ext.create('Deft.Deferred');

    let default_config = {
      model: 'Defect',
      fetch: ['ObjectID']
    };

    Ext.create('Rally.data.wsapi.Store', Ext.Object.merge(default_config, config)).load({
      callback: function (records, operation, successful) {
        if (successful) {
          if (returnOperation) {
            deferred.resolve(operation);
          } else {
            deferred.resolve(records);
          }
        } else {
          deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
        }
      }
    });
    return deferred.promise;
  },

  loadWsapiRecordsAsync(config, returnOperation) {
    return this.wrap(this.loadWsapiRecords(config, returnOperation));
  },

  loadWsapiRecordsWithParallelPages: function (config, msg) {
    let deferred = Ext.create('Deft.Deferred'),
      me = this;

    let count_check_config = Ext.clone(config);
    count_check_config.limit = 1;
    count_check_config.pageSize = 1;
    count_check_config.fetch = ['ObjectID'];

    this.loadWsapiRecords(count_check_config, true).then({
      success: function (operation) {
        config.pageSize = 200;
        config.limit = config.pageSize;
        let total = operation.resultSet.totalRecords;
        let page_count = Math.ceil(total / config.pageSize);

        let promises = [];
        Ext.Array.each(_.range(1, page_count + 1), function (page_index) {
          let config_clone = Ext.clone(config);
          config_clone.currentPage = page_index;
          promises.push(function () {
            let percentage = parseInt((page_index * 100) / page_count, 10);
            let message = msg || 'Loading values';
            Rally.getApp().setLoading(message + ' (' + percentage + '%)');
            return me.loadWsapiRecords(config_clone);
          });
        });
        CA.techservices.promise.ParallelThrottle.throttle(promises, 6, me).then({
          success: function (results) {
            deferred.resolve(Ext.Array.flatten(results));
          },
          failure: function (msg) {
            deferred.reject(msg);
          }
        });
      },
      failure: function (msg) {
        deferred.reject(msg);
      }
    });
    return deferred.promise;
  },

  getPreferenceProject: function () {
    return Rally.getApp().getSetting('preferenceProjectRef');
  },

  isEditableProjectForCurrentUser: function (projectRef, scope) {
    let app = scope || Rally.getApp(),
      me = this;

    if (this.currentUserIsAdmin(scope)) {
      return true;
    }

    let project_oid = this._getOidFromRef(projectRef);
    let editor_permissions = Ext.Array.filter(app.getContext().getPermissions().userPermissions, function (permission) {
      if (permission.Role != 'Editor' && permission.Role != 'ProjectAdmin') {
        return false;
      }

      return me._getOidFromRef(permission._ref) == project_oid;
    });

    return editor_permissions.length > 0;
  },

  getEditableProjectForCurrentUser: function () {
    let app = Rally.getApp();
    if (this._currentUserCanWrite()) {
      return app.getContext().getProjectRef();
    }

    let workspace_oid = this._getOidFromRef(app.getContext().getWorkspaceRef());

    let editor_permissions = Ext.Array.filter(
      app.getContext().getPermissions().userPermissions,
      function (permission) {
        if (Ext.isEmpty(permission.Workspace)) {
          return false;
        }
        let permission_oid = this._getOidFromRef(permission.Workspace);

        if (workspace_oid != permission_oid) {
          return false;
        }

        return permission.Role == 'Editor' || permission.Role == 'ProjectAdmin';
      },
      this
    );

    if (editor_permissions.length > 0) {
      return editor_permissions[0]._ref;
    }
    return false;
  },

  _getOidFromRef: function (ref) {
    let ref_array = ref.replace(/\.js$/, '').split(/\//);
    return ref_array[ref_array.length - 1].replace(/\.js/, '');
  },

  // true if sub or workspace admin
  currentUserIsAdmin: function (scope) {
    let app = scope || Rally.getApp();

    if (this.currentUserIsSubAdmin()) {
      return true;
    }

    let permissions = app.getContext().getPermissions().userPermissions;

    let workspace_admin_list = Ext.Array.filter(permissions, function (p) {
      return p.Role == 'Workspace Admin' || p.Role == 'Subscription Admin';
    });

    let current_workspace_ref = app.getContext().getWorkspace()._ref;
    let is_workspace_admin = false;

    if (workspace_admin_list.length > 0) {
      Ext.Array.each(workspace_admin_list, function (p) {
        if (current_workspace_ref.replace(/\.js$/, '') == p._ref.replace(/\.js$/, '')) {
          is_workspace_admin = true;
        }
      });
    }

    return is_workspace_admin;
  },

  currentUserIsSubAdmin: function (scope) {
    let app = scope || Rally.getApp();

    let permissions = app.getContext().getPermissions().userPermissions;

    let sub_admin_list = Ext.Array.filter(permissions, function (p) {
      return p.Role == 'Subscription Admin';
    });

    return sub_admin_list.length > 0;
  },

  _currentUserCanWrite: function () {
    let app = Rally.getApp();

    if (app.getContext().getUser().SubscriptionAdmin) {
      return true;
    }

    let permissions = app.getContext().getPermissions().userPermissions;

    let workspace_admin_list = Ext.Array.filter(permissions, function (p) {
      return p.Role == 'Workspace Admin' || p.Role == 'Subscription Admin';
    });

    let current_workspace_ref = app.getContext().getWorkspace()._ref;
    let can_unlock = false;

    if (workspace_admin_list.length > 0) {
      Ext.Array.each(workspace_admin_list, function (p) {
        if (current_workspace_ref.replace(/\.js$/, '') == p._ref.replace(/\.js$/, '')) {
          can_unlock = true;
        }
      });
    }

    return can_unlock;
  },

  _currentUserCanUnapprove: function () {
    return this.currentUserIsAdmin();
  },

  async getCurrentUserIsTimeSheetAdmin() {
    const users = await this.wrap(Ext.create(Rally.data.wsapi.RefsToRecords).convert([Rally.getApp().getContext().getUser()._ref])).catch(() => null);

    if (users && users.length) {
      return !!users[0].get('c_TimesheetAdmin');
    }

    return false;
  },

  fetchPortfolioItemTypes() {
    let config = {
      model: 'TypeDefinition',
      fetch: ['TypePath', 'Ordinal', 'Name'],
      filters: [{ property: 'TypePath', operator: 'contains', value: 'PortfolioItem/' }],
      sorters: [{ property: 'Ordinal', direction: 'ASC' }]
    };

    return this.loadWsapiRecordsAsync(config);
  },

  fetchField: function (modelName, fieldName) {
    let deferred = Ext.create('Deft.Deferred');
    Rally.data.ModelFactory.getModel({
      type: modelName,
      success: function (model) {
        deferred.resolve(model.getField(fieldName));
      },
      failure: function () {
        let error = 'Could not load schedule states';
        deferred.reject(error);
      }
    });
    return deferred.promise;
  },

  wrap(deferred) {
    if (!deferred || !_.isFunction(deferred.then)) {
      return Promise.reject(new Error('Wrap cannot process this type of data into a ECMA promise'));
    }
    return new Promise((resolve, reject) => {
      deferred.then({
        success(...args) {
          resolve(...args);
        },
        failure(error) {
          Rally.getApp().setLoading(false);
          reject(error);
        },
        scope: this
      });
    });
  }
});

                Ext.define('TSDateUtils', {
  singleton: true,

  getBeginningOfWeekForLocalDate: function (week_date, weekStartDay) {
    if (Ext.isEmpty(weekStartDay)) {
      weekStartDay = 0;
    }

    let dayInWeek = week_date.getDay();
    if (week_date.getUTCHours() === 0) {
      // already in UTC
      dayInWeek = week_date.getUTCDay();
    }
    let delta = weekStartDay - dayInWeek;
    if (dayInWeek < weekStartDay) {
      delta = weekStartDay - dayInWeek - 7;
    }

    let start_of_week_here = Ext.Date.add(week_date, Ext.Date.DAY, delta);
    return start_of_week_here;
  },

  getBeginningOfWeekISOForLocalDate: function (week_date, showShiftedTimeStamp, weekStartDay) {
    if (Ext.isEmpty(weekStartDay)) {
      weekStartDay = 0;
    }

    let local_beginning = TSDateUtils.getBeginningOfWeekForLocalDate(week_date, weekStartDay);

    if (showShiftedTimeStamp) {
      return Rally.util.DateTime.toIsoString(local_beginning).replace(/T.*$/, 'T00:00:00.0Z');
    }

    if (local_beginning.getUTCHours() === 0) {
      return Rally.util.DateTime.toIsoString(local_beginning, true).replace(/T.*$/, '');
    }
    return Rally.util.DateTime.toIsoString(local_beginning, false).replace(/T.*$/, '');
  },

  formatShiftedDate: function (jsdate, format) {
    let offset = jsdate.getTimezoneOffset(); // 480 is pacific, -330 is india

    if (offset > 0) {
      jsdate = Rally.util.DateTime.add(jsdate, 'minute', offset);
    }

    return Ext.util.Format.date(jsdate, format);
  },

  pretendIMeantUTC: function (jsdate, asUTC) {
    let offset = jsdate.getTimezoneOffset();

    if (asUTC) {
      return Rally.util.DateTime.toIsoString(jsdate).replace(/T.*$/, 'T00:00:00.000Z');
    }
    let shiftedDate = Rally.util.DateTime.add(jsdate, 'minute', -1 * offset);

    return shiftedDate;
  },

  // returns a promise, fulfills with a boolean
  isApproved: function (week_start_iso, user_oid) {
    let deferred = Ext.create('Deft.Deferred');

    let short_iso_date = week_start_iso;
    let key_user_oid = user_oid || Rally.getApp().getContext().getUser().ObjectID;

    let key = Ext.String.format('{0}.{1}.{2}', TSUtilities.approvalKeyPrefix, short_iso_date, key_user_oid);

    this._loadWeekStatusPreference(key).then({
      success: function (preference) {
        if (preference.length === 0) {
          deferred.resolve(false);
          return;
        }
        let value = preference[0].get('Value');
        if (/{/.test(value)) {
          let status_object = Ext.JSON.decode(value);
          if (status_object.status == 'Approved') {
            deferred.resolve(true);
            return;
          }
        }

        deferred.resolve(false);
      },
      failure: function (msg) {
        deferred.reject(msg);
      }
    });

    return deferred.promise;
  },

  _loadWeekStatusPreference: function (key) {
    let config = {
      model: 'Preference',
      limit: 1,
      pageSize: 1,
      filters: [
        { property: 'Name', operator: 'contains', value: key },
        { property: 'Name', operator: '!contains', value: TSUtilities.archiveSuffix }
      ],
      fetch: ['Name', 'Value'],
      sorters: [{ property: 'CreationDate', direction: 'DESC' }]
    };

    return TSUtilities.loadWsapiRecords(config);
  }
});

                Ext.define('TSArrowedDate', {
  extend: 'Ext.container.Container',
  alias: 'widget.tsarroweddate',

  layout: 'hbox',

  items: [
    { xtype: 'rallybutton', itemId: 'previous_button', cls: 'secondary', ui: 'tsnav', text: '<<' },
    { xtype: 'rallydatefield', itemId: 'date_field' },
    { xtype: 'rallybutton', itemId: 'next_button', cls: 'secondary', ui: 'tsnav', text: ' >>' }
  ],

  constructor: function (config) {
    this.mergeConfig(config);

    this.callParent([this.config]);
  },

  initComponent: function () {
    this.callParent(arguments);

    this.addEvents(
      /**
       * @event
       * Fires when the grid has been rendered
       * @param {TSArrowedDate} datefield
       * @param {date} new value
       * @param {date} old value
       */
      'change'
    );

    if (this.value) {
      this.down('rallydatefield').setValue(this.value);
    }

    this.down('rallydatefield').on('change', this._onDateChanged, this);
    this.down('#previous_button').on('click', this._onPreviousButtonClicked, this);
    this.down('#next_button').on('click', this._onNextButtonClicked, this);
  },

  _onDateChanged: function (picker, new_value, old_value) {
    this.fireEvent('change', this, new_value, old_value);
  },

  setValue: function (value) {
    this.down('rallydatefield').setValue(value);
  },

  getValue: function () {
    return this.down('rallydatefield').getValue();
  },

  _onPreviousButtonClicked: function () {
    let value = this.getValue();
    if (Ext.isEmpty(value)) {
      return;
    }

    this.setValue(Rally.util.DateTime.add(value, 'day', -7));
  },

  _onNextButtonClicked: function () {
    let value = this.getValue();
    if (Ext.isEmpty(value)) {
      return;
    }

    this.setValue(Rally.util.DateTime.add(value, 'day', 7));
  }
});

                /**
 * A dialog that displays artifacts to choose from
 *
 */
Ext.define('Rally.technicalservices.ChooserDialog', {
  extend: 'Rally.ui.dialog.Dialog',
  alias: 'widget.tschooserdialog',

  clientMetrics: [
    {
      beginEvent: 'beforeshow',
      endEvent: 'show',
      description: 'dialog shown'
    }
  ],

  width: 800,
  maxHeight: '100%',
  closable: true,

  searchContext: 'project',

  config: {
    /**
     * @cfg {String}
     * Title to give to the dialog
     */
    title: 'Choose an Artifact',
    /**
     * @cfg {Array} (required)
     * List of artifact types to allow the user to choose from
     */
    artifactTypes: [],
    /**
     * @cfg {Boolean}
     * Allow multiple selection or not
     */
    multiple: false,

    /**
     * @cfg {Object}
     * An {Ext.data.Store} config object used when building the grid
     * Handy when you need to limit the selection with store filters
     */
    storeConfig: {},

    /**
     * @cfg {Object}
     * The list of filter configs that will appear in the filter combobox
     * Each list element should include a displayName and an attributeName property,
     * where the attributeName is the name of wsapi queryable attribute:
     *     {
     *         displayName: 'Formatted ID',
     *         attributeName: 'FormattedID'
     *     }
     */
    filterableFields: [],

    /**
     * @cfg {Ext.grid.Column}
     * List of columns that will be used in the chooser
     */
    columns: [],

    /**
     * @cfg [{String}]
     * List of field names to fetch when getting the objects
     */
    fetchFields: [],

    /**
     * @cfg {String}
     * Text to be displayed on the button when selection is complete
     */
    selectionButtonText: 'Done',

    /**
     * @cfg {Object}
     * The grid configuration to be used when creative the grid of items in the dialog
     */
    gridConfig: {},

    /**
     * @cfg {String}
     * The ref of a record to select when the chooser loads
     */
    selectedRef: undefined

    /**
     * @private
     * @cfg userAction {String} (Optional)
     * The client metrics action to record when the user makes a selection and clicks done
     */
  },

  items: {
    xtype: 'panel',
    border: false,
    items: [
      {
        xtype: 'container',
        itemId: 'gridContainer',
        layout: 'fit',
        height: 400
      }
    ]
  },

  constructor: function (config) {
    this.mergeConfig(config);

    this.callParent([this.config]);
  },

  initComponent: function () {
    this.callParent(arguments);
    this.addEvents(
      /**
       * @event artifactChosen
       * Fires when user clicks done after choosing an artifact
       * @param {Rally.technicalservices.ChooserDialog} this dialog
       * @param {Rally.domain.WsapiModel} selected record or an array of selected records if multiple is true
       */
      'artifactChosen'
    );

    this.addCls('chooserDialog');

    this._buildButtons();
    this._buildSearchBar();

    Rally.data.ModelFactory.getModels({
      types: this.artifactTypes,
      success: function (models) {
        this.models = models;

        if (this.artifactTypes.length > 1) {
          this._setupComboBox(models);
        }

        this._buildGrid(models[this.artifactTypes[0]]);
      },
      scope: this
    });
  },

  /**
   * @private
   */
  _buildButtons: function () {
    this.down('panel').addDocked({
      xtype: 'toolbar',
      dock: 'bottom',
      padding: '0 0 10 0',
      layout: {
        type: 'hbox',
        pack: 'center'
      },
      ui: 'footer',
      items: [
        {
          xtype: 'rallybutton',
          text: this.selectionButtonText,
          cls: 'primary small',
          scope: this,
          userAction: 'clicked done in dialog',
          handler: function () {
            let selectedRecords = this._getSelectedRecords();
            if (!this.multiple) {
              selectedRecords = selectedRecords[0];
            }
            this.fireEvent('artifactChosen', this, selectedRecords);
            this.close();
          }
        },
        {
          xtype: 'rallybutton',
          text: 'Cancel',
          cls: 'secondary small',
          handler: this.close,
          scope: this,
          ui: 'link'
        }
      ]
    });
  },

  /**
   * @private
   */
  _buildSearchBar: function () {
    let filterTypeComboBox = Ext.create('Ext.form.field.ComboBox', {
      itemId: 'filterTypeComboBox',
      queryMode: 'local',
      store: Ext.create('Ext.data.Store', {
        fields: ['attributeName', 'displayName'],
        data: this.filterableFields
      }),
      displayField: 'displayName',
      valueField: 'attributeName',
      editable: false
    });

    filterTypeComboBox.select(filterTypeComboBox.getStore().getAt(1));

    this.addDocked({
      xtype: 'toolbar',
      itemId: 'searchBar',
      dock: 'top',
      items: [
        filterTypeComboBox,
        {
          xtype: 'textfield',
          itemId: 'searchTerms',
          emptyText: 'enter search terms',
          flex: 1,
          enableKeyEvents: true,
          listeners: {
            keyup: function (textField, event) {
              if (event.getKey() === Ext.EventObject.ENTER) {
                this._search();
              }
            },
            scope: this
          }
        },
        {
          xtype: 'button',
          text: '<span class="icon-search"> </span>',
          handler: this._openSearchMenu,
          scope: this
        }
      ]
    });

    filterTypeComboBox.on('change', this._changeSearchField, this);
  },

  _changeSearchField: function (field_combobox) {
    let field_name = field_combobox.getValue();

    let search_config = {
      itemId: 'searchTerms',
      emptyText: 'enter search terms',
      flex: 1
    };

    let field = this.models[this.artifactTypes[0]].getField(field_name);

    let editor_config = {
      xtype: 'textfield',
      enableKeyEvents: true,
      listeners: {
        keyup: function (textField, event) {
          if (event.getKey() === Ext.EventObject.ENTER) {
            this._search();
          }
        },
        scope: this
      }
    };

    if (field && field.editor && field.editor.field) {
      editor_config = field.editor.field;

      // for timeboxes to load:
      delete editor_config.storeConfig;
      editor_config.defaultToCurrentTimebox = true;
      editor_config.autoSelectCurrentItem = true;

      if (editor_config.xtype == 'rallytextfield') {
        editor_config.enableKeyEvents = true;
        editor_config.listeners = {
          keyup: function (textField, event) {
            if (event.getKey() === Ext.EventObject.ENTER) {
              this._search();
            }
          },
          scope: this
        };
      } else {
        editor_config.listeners = {
          scope: this,
          change: this._search,
          select: this._search
        };
      }
    }

    let config = Ext.Object.merge(search_config, editor_config);

    let index = this.down('#searchBar').items.length - 2;
    this.down('#searchTerms') && this.down('#searchTerms').destroy();
    this.down('#searchBar').insert(index, config);
  },

  /**
   * @private
   * @param {Object} models Object with {Rally.domain.WsapiModel} items
   *
   */
  _setupComboBox: function (models) {
    let searchBar = this.down('#searchBar');
    let combo = Ext.create('Ext.form.field.ComboBox', {
      xtype: 'combo',
      name: 'filterType',
      queryMode: 'local',
      store: Ext.create('Ext.data.Store', {
        fields: ['typeName', 'displayName', 'wsapiModel']
      }),
      displayField: 'displayName',
      valueField: 'typeName',
      editable: false
    });
    searchBar.insert(0, combo);

    Ext.Object.each(
      models,
      function (key, model) {
        combo.getStore().add({
          typeName: model.typePath,
          displayName: model.displayName,
          wsapiModel: model
        });
      },
      this
    );

    combo.select(combo.getStore().getAt(0));

    combo.on(
      'select',
      function (comboBox, options) {
        let option = options[0];
        this.grid.reconfigureWithModel(option.get('wsapiModel'));
      },
      this
    );
  },

  /**
   * @private
   * @param {Rally.domain.WsapiModel}
   *
   */
  _buildGrid: function (model) {
    let mode = this.multiple ? 'MULTI' : 'SINGLE';
    this.selectionModel = Ext.create('Rally.ui.selection.CheckboxModel', {
      mode: mode,
      allowDeselect: true
    });

    let store_config = this.storeConfig;
    store_config.context = { project: Rally.getApp().getContext().getProjectRef() };

    let new_fetch = Ext.Array.merge(['ObjectID'], this.fetchFields);
    let current_fetch = store_config.fetch || [];

    store_config.fetch = Ext.Array.merge(new_fetch, current_fetch);

    let gridConfig = Ext.Object.merge(
      {
        model: model,
        selModel: this.selectionModel,
        autoAddAllModelFieldsAsColumns: false,
        enableEditing: false,
        enableColumnHide: false,
        enableColumnMove: false,
        columnCfgs: this.columns,
        storeConfig: store_config,
        showRowActionsColumn: false,
        viewConfig: {
          emptyText: Rally.ui.EmptyTextFactory.get('defaultText')
        }
      },
      this.config.gridConfig
    );

    this.grid = Ext.create('Rally.ui.grid.Grid', gridConfig);
    this.mon(this.grid, 'load', this._onGridLoad, this);
    this.down('#gridContainer').add(this.grid);
    this._onGridReady();
  },

  _onGridReady: function () {
    if (!this.grid.rendered) {
      this.mon(this.grid, 'afterrender', this._onGridReady, this, { single: true });
      return;
    }

    if (this.grid.getStore().isLoading()) {
      this.mon(this.grid, 'load', this._onGridReady, this, { single: true });
      return;
    }

    this._onGridLoad();
    this.down('#gridContainer').setHeight(Math.min(Rally.getApp().getHeight() - 125, 400));
    this.center();

    if (Rally.BrowserTest) {
      Rally.BrowserTest.publishComponentReady(this);
    }
  },

  _onGridLoad: function () {
    if (this.getSelectedRef()) {
      let recordIndex = this.grid.getStore().find('_ref', this.getSelectedRef());
      if (recordIndex !== -1) {
        let record = this.grid.getStore().getAt(recordIndex);
        this.grid.getSelectionModel().select(record);
      }
    }
  },

  /**
   * @private
   * @return {Rally.data.Model}
   */
  _getSelectedRecords: function () {
    return this.selectionModel.getSelection();
  },

  /**
   * @private
   */
  _search: function () {
    let terms = this.down('#searchTerms').getValue();
    let filterBy = this.down('#filterTypeComboBox').getValue();
    let filter;

    let store_config = this.grid.storeConfig;

    store_config.context = { project: Rally.getApp().getContext().getProjectRef() };

    if (this.searchContext == 'workspace') {
      store_config.context = { project: null };
    }

    let store = this.grid.getStore();
    store.context = store_config.context;

    if (!Ext.isEmpty(terms)) {
      filter = Ext.create('Rally.data.wsapi.Filter', {
        property: filterBy,
        value: terms,
        operator: 'Contains'
      });
    }

    if (Ext.isFunction(this.down('#searchTerms').getQueryFromSelected)) {
      filter = this.down('#searchTerms').getQueryFromSelected();
    }

    this.grid.filter(filter, true);
  },

  _openSearchMenu: function (button) {
    let menu = Ext.widget({
      xtype: 'rallymenu',
      items: [
        {
          text: 'Search Selected Project',
          handler: function () {
            this.searchContext = 'project';
            this._search();
          },
          scope: this
        },
        {
          text: 'Search Everywhere',
          handler: function () {
            this.searchContext = 'workspace';
            this._search();
          },
          scope: this
        }
      ]
    });
    menu.showBy(button.getEl());
    if (button.toolTip) {
      button.toolTip.hide();
    }
  }
});

                Ext.define('CA.technicalservices.ColumnPickerDialog', {
  extend: 'Rally.ui.dialog.Dialog',
  alias: 'widget.tscolumnpickerdialog',

  width: 200,
  closable: true,

  config: {
    /**
     * @cfg {String}
     * Title to give to the dialog
     */
    title: 'Choose Columns',
    /**
     * @cfg {Boolean}
     * Allow multiple selection or not
     */
    multiple: true,
    /**
     *
     * @cfg [{Ext.Column.column}]  columns that
     * can be chosen.  hidden = false means chosen to
     * show.
     *
     */
    pickableColumns: [],

    selectionButtonText: 'Apply'
  },

  items: [
    {
      xtype: 'panel',
      border: false,
      items: [
        {
          xtype: 'container',
          itemId: 'grid_container',
          layout: 'fit',
          height: 325
        }
      ]
    }
  ],

  constructor: function (config) {
    this.mergeConfig(config);

    this.callParent([this.config]);
  },

  initComponent: function () {
    this.callParent(arguments);
    this.addEvents(
      /**
       * @event columnschosen
       * Fires when user clicks done after choosing columns
       * @param {CA.technicalservices.ColumnPickerDialog} this dialog
       * @param [{Ext.column.Column}] columns with hidden marked true/false as appropriate
       */
      'columnschosen'
    );

    this._buildButtons();
    //this._buildSearchBar();
    this._buildGrid();
  },

  _buildButtons: function () {
    this.down('panel').addDocked({
      xtype: 'toolbar',
      dock: 'bottom',
      padding: '0 0 10 0',
      layout: {
        type: 'hbox',
        pack: 'center'
      },
      ui: 'footer',
      items: [
        {
          xtype: 'rallybutton',
          text: this.selectionButtonText,
          cls: 'primary small',
          scope: this,
          userAction: 'clicked done in dialog',
          handler: function () {
            let selectedRecords = this.getRecordsWithSelection();
            this.fireEvent('columnschosen', this, selectedRecords);
            this.close();
          }
        },
        {
          xtype: 'rallybutton',
          text: 'Cancel',
          cls: 'secondary small',
          handler: this.close,
          scope: this,
          ui: 'link'
        }
      ]
    });
  },

  _buildGrid: function () {
    let mode = this.multiple ? 'MULTI' : 'SINGLE';
    this.selectionModel = Ext.create('Rally.ui.selection.CheckboxModel', {
      mode: mode,
      allowDeselect: true
    });

    let pickableColumns = this.pickableColumns;

    let store = Ext.create('Rally.data.custom.Store', {
      data: this.pickableColumns
    });

    this.grid = Ext.create('Rally.ui.grid.Grid', {
      selModel: this.selectionModel,
      enableColumnHide: false,
      enableColumnMove: false,
      columnCfgs: this._getGridColumns(),
      showPagingToolbar: false,
      showRowActionsColumn: false,
      store: store,
      listeners: {
        viewready: function (grid) {
          let selectionModel = grid.getSelectionModel();

          Ext.Array.each(pickableColumns, function (col, idx) {
            if (!col.hidden) {
              selectionModel.select(grid.store.data.items[idx], true);
            }
          });
        }
      }
    });

    this.down('#grid_container').add(this.grid);
  },

  _getGridColumns: function () {
    return [{ dataIndex: 'text', flex: 1 }];
  },

  getRecordsWithSelection: function () {
    let selected_items = this.grid.getSelectionModel().getSelection();
    let selected_items_by_dataindex = {};
    Ext.Array.each(selected_items, function (selected_item) {
      selected_items_by_dataindex[selected_item.get('text')] = selected_item.getData();
    });

    Ext.Array.each(this.pickableColumns, function (pickableColumn) {
      pickableColumn.hidden = Ext.isEmpty(selected_items_by_dataindex[pickableColumn.text]);
    });

    return this.pickableColumns;
  }
});

                Ext.define('CA.technicalservices.ColumnPickerButton', {
  extend: 'Rally.ui.Button',
  requires: ['CA.technicalservices.ColumnPickerDialog'],

  alias: 'widget.tscolumnpickerbutton',

  config: {
    pickableColumns: [],
    text: '<span class="icon-add-column"> </span>',
    cls: 'secondary'
  },

  constructor: function (config) {
    this.mergeConfig(config);

    this.callParent([this.config]);
  },

  initComponent: function () {
    this.callParent(arguments);
    this.addEvents(
      /**
       * @event columnschosen
       * Fires when user clicks done after choosing columns
       * @param {CA.technicalservices.ColumnPickerButton} this button
       * @param [{Ext.column.Column}] columns with hidden marked true/false as appropriate
       */
      'columnschosen'
    );
  },

  afterRender: function () {
    this.callParent(arguments);
    this.mon(this.el, this.clickEvent, this._showDialog, this);
  },

  _showDialog: function () {
    let me = this;
    Ext.create('CA.technicalservices.ColumnPickerDialog', {
      autoShow: true,
      pickableColumns: this.pickableColumns,
      listeners: {
        scope: this,
        columnschosen: function (dialog, columns) {
          this.fireEvent('columnschosen', me, columns);
        }
      }
    });
  }
});

                Ext.define('CA.technicalservices.TimeDetailsDialog', {
  extend: 'Rally.ui.dialog.Dialog',
  alias: 'widget.tstimedetailsdialog',

  closable: true,

  layout: 'border',

  currentDay: null,

  timeBlocks: [],

  config: {
    /**
     * @cfg {String}
     * Title to give to the dialog
     */
    title: 'Time Details',

    row: null, // a time sheet row,

    autoShow: true,

    height: 400,
    width: 600
  },

  items: [
    {
      xtype: 'container',
      layout: 'hbox',
      items: [
        {
          xtype: 'container',
          itemId: 'daysContainer',
          layout: 'vbox',
          width: 150
        },
        {
          xtype: 'container',
          itemId: 'dayContainer',
          //                border: 1,
          //                style: {borderColor:'#f00', borderStyle:'solid', borderWidth:'1px'},
          width: 450
        }
      ]
    }
  ],

  constructor: function (config) {
    this.mergeConfig(config);

    this.callParent([this.config]);
  },

  initComponent: function () {
    this.callParent(arguments);

    this.currentDay = new Date().getDay();

    this._buildDays();

    this._buildForm();
  },

  _buildDays: function () {
    let me = this,
      days = CA.techservices.timesheet.TimeRowUtils.daysInOrder;

    let container = this.down('#daysContainer');
    this.day_boxes = {};

    Ext.Array.each(days, function (day) {
      me.day_boxes[day] = container.add({
        item_id: 'day_box_' + day,
        xtype: 'container',
        margin: 10,
        tpl: '<span class="day_name">{day}</span>: <span class="day_value">{value}</day>'
      });

      let value = me._getHoursForDay(day);
      me.day_boxes[day].update({ day: day, value: value });
    });
  },

  _getHoursForDay: function (day_name) {
    let time_entry_value = this.row.getTimeEntryValue(day_name);
    let value = 0;

    if (!Ext.isEmpty(time_entry_value)) {
      value = time_entry_value.get('Hours');
    }

    return value;
  },

  _buildForm: function () {
    let me = this,
      container = this.down('#dayContainer');

    this._buildNavigation(container);
    container.add({
      xtype: 'container',
      itemId: 'detailsPanel',
      layout: 'vbox',
      width: '100%',
      height: 275,
      padding: 3
    });
    this._updateDetailsPanel();
    this._addAddButton(container);
  },

  _buildNavigation: function (container) {
    let me = this;

    let selector_box = container.add({
      xtype: 'container',
      layout: 'hbox'
    });

    selector_box.add({
      xtype: 'rallybutton',
      text: '<span class="icon-left"> </span>',
      cls: 'secondary small',
      listeners: {
        scope: this,
        click: this._moveLeft
      }
    });

    selector_box.add({ xtype: 'container', flex: 1 });

    selector_box
      .add({
        xtype: 'container',
        tpl: '{day}',
        itemId: 'day_selector_display'
      })
      .update({ day: CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay] });

    selector_box.add({ xtype: 'container', flex: 1 });

    selector_box.add({
      xtype: 'rallybutton',
      text: '<span class="icon-right"> </span>',
      cls: 'secondary small',
      listeners: {
        scope: this,
        click: this._moveRight
      }
    });
  },

  _moveLeft: function () {
    this.currentDay = this.currentDay - 1;
    if (this.currentDay < 0) {
      this.currentDay = 6;
    }
    this.down('#day_selector_display').update({ day: CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay] });
    this._updateDetailsPanel();
  },

  _moveRight: function () {
    this.currentDay = this.currentDay + 1;
    if (this.currentDay > 6) {
      this.currentDay = 0;
    }
    this.down('#day_selector_display').update({ day: CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay] });
    this._updateDetailsPanel();
  },

  _updateDetailsPanel: function () {
    let me = this,
      container = this.down('#detailsPanel');
    container.removeAll();

    let today_details = this.row.getTimeBlocks(CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay]);

    container.add({
      xtype: 'container',
      itemId: 'time_block_container',
      flex: 1,
      layout: 'vbox'
    });

    this.timeBlocks = [];

    if (!Ext.isEmpty(today_details)) {
      Ext.Array.each(
        today_details,
        function (detail) {
          this._addTimeBlock(detail);
        },
        this
      );
    }

    let current_total = this._getHoursForDay(CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay]);

    let adjustment = current_total - this._getTotal();
    if (adjustment < 0) {
      adjustment = 0;
    }

    this._addDailyAdjustmentBox(container, adjustment);
    this._enableDisableAddButton();
  },

  _addAddButton: function (container) {
    let button_container = container.add({
      xtype: 'container',
      layout: 'hbox',
      width: '100%',
      padding: 10
    });

    button_container.add({ xtype: 'container', flex: 1 });

    button_container.add({
      xtype: 'rallybutton',
      itemId: 'add_block_button',
      cls: 'small secondary',
      text: '+',
      listeners: {
        scope: this,
        click: function (button) {
          this._addTimeBlock();
        }
      }
    });
  },

  _addDailyAdjustmentBox: function (container, adjustment) {
    let adjustment_container = container.add({
      xtype: 'container',
      layout: 'hbox',
      width: '100%',
      margin: 7
    });

    adjustment_container.add({ xtype: 'container', flex: 1 });

    let field = adjustment_container.add({
      itemId: 'adjustment_box',
      xtype: 'rallynumberfield',
      value: adjustment,
      labelWidth: 75,
      width: 130,
      fieldLabel: 'Adjustment:',
      maxValue: 36,
      minValue: 0
    });

    field.on('change', this._recalculateTotal, this);
  },

  _removeTimeBlock: function (block, fields) {
    Ext.Array.each(fields.reverse(), function (field) {
      field.setValue(0);
    });

    this.row.removeTimeBlock(CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay], block.itemId);
    block.destroy();

    this._enableDisableAddButton();
  },

  _addTimeBlock: function (detail) {
    let container = this.down('#time_block_container');

    let item_id = new Date().getTime();
    if (!Ext.isEmpty(detail)) {
      item_id = detail.id;
    }

    let block = container.add({
      xtype: 'container',
      layout: 'hbox',
      itemId: item_id,
      defaults: { margin: 3 }
    });

    let hours = [
      { display: '12A', value: 0 },
      { display: '1 A', value: 1 },
      { display: '2 A', value: 2 },
      { display: '3 A', value: 3 },
      { display: '4 A', value: 4 },
      { display: '5 A', value: 5 },
      { display: '6 A', value: 6 },
      { display: '7 A', value: 7 },
      { display: '8 A', value: 8 },
      { display: '9 A', value: 9 },
      { display: '10A', value: 10 },
      { display: '11A', value: 11 },
      { display: '12P', value: 12 },
      { display: '1 P', value: 13 },
      { display: '2 P', value: 14 },
      { display: '3 P', value: 15 },
      { display: '4 P', value: 16 },
      { display: '5 P', value: 17 },
      { display: '6 P', value: 18 },
      { display: '7 P', value: 19 },
      { display: '8 P', value: 20 },
      { display: '9 P', value: 21 },
      { display: '10P', value: 22 },
      { display: '11P', value: 23 }
    ];

    let hour_store_start = Ext.create('Rally.data.custom.Store', {
      fields: ['display', 'value'],
      data: Ext.clone(hours)
    });

    let hour_store_end = Ext.create('Rally.data.custom.Store', {
      fields: ['display', 'value'],
      data: Ext.clone(hours)
    });

    let now = new Date();
    let hour_field_start = {
      xtype: 'rallycombobox',
      itemId: 'start_hour',
      fieldLabel: ' ',
      allowNoEntry: false,
      store: hour_store_start,
      queryMode: 'local',
      displayField: 'display',
      valueField: 'value',
      width: 95,
      labelWidth: 30,
      value: now.getHours()
    };

    let minute_field_start = {
      xtype: 'rallynumberfield',
      itemId: 'start_minute',
      fieldLabel: '  ',
      maxValue: 59,
      minValue: 0,
      //            spinDownEnabled: false,
      //            spinUpEnabled: false,
      width: 55,
      labelWidth: 5,
      value: now.getMinutes()
    };

    let hour_field_end = {
      xtype: 'rallycombobox',
      itemId: 'end_hour',
      allowNoEntry: true,
      noEntryText: ' ',
      noEntryValue: null,
      fieldLabel: 'to',
      store: hour_store_end,
      queryMode: 'local',
      displayField: 'display',
      valueField: 'value',
      width: 85,
      labelWidth: 20
    };

    let minute_field_end = {
      xtype: 'rallynumberfield',
      itemId: 'end_minute',
      fieldLabel: '  ',
      maxValue: 59,
      minValue: 0,
      //            spinDownEnabled: false,
      //            spinUpEnabled: false,
      width: 55,
      labelWidth: 5
    };

    let total_field = {
      xtype: 'rallynumberfield',
      itemId: 'block_total',
      fieldLabel: ' = ',
      labelSeparator: '',
      editable: false,
      maxValue: 36,
      minValue: 0,
      spinDownEnabled: false,
      spinUpEnabled: false,
      width: 65,
      labelWidth: 5
    };

    hour_field_start.value = new Date().getHours();
    minute_field_start.value = new Date().getMinutes();

    if (!Ext.isEmpty(detail)) {
      hour_field_start.value = detail.start_hour;
      minute_field_start.value = detail.start_minute;
      hour_field_end.value = detail.end_hour;
      minute_field_end.value = detail.end_minute;
    }

    let fields = [block.add(hour_field_start), block.add(minute_field_start), block.add(hour_field_end), block.add(minute_field_end)];

    block.add({ xtype: 'container', flex: 1 });
    block.add(total_field);

    block.add({
      xtype: 'rallybutton',
      itemId: 'remove_block_button',
      cls: 'no-border',
      text: '<span class="icon-cancel"> </span>',
      listeners: {
        scope: this,
        click: function (button) {
          this._removeTimeBlock(block, fields);
        }
      }
    });

    Ext.Array.each(
      fields,
      function (field) {
        field.on(
          'change',
          function () {
            this._setValidBlockValues(block);
          },
          this
        );
        field.on(
          'change',
          function () {
            this._updateRow(block);
          },
          this
        );
        field.on(
          'change',
          function () {
            this._updateBlockTotal(block);
          },
          this
        );
        // only update row total after block changes (not when first launched)
        field.on('change', this._recalculateTotal, this);
      },
      this
    );

    this.timeBlocks.push(block);

    this._setValidBlockValues(block);
    this._updateRow(block);
    this._updateBlockTotal(block);
  },

  _setValidBlockValues: function (block) {
    let start_hour = block.down('#start_hour').getValue();
    let start_minute = block.down('#start_minute').getValue();
    let end_hour = block.down('#end_hour').getValue();
    let end_minute = block.down('#end_minute').getValue();

    if (Ext.isEmpty(start_hour)) {
      return;
    }

    let end_store = block.down('#end_hour').getStore();
    end_store.clearFilter(true);
    end_store.addFilter({ property: 'value', operator: '>=', value: start_hour });

    if (Ext.isEmpty(end_hour)) {
      return;
    }

    if (start_hour > end_hour) {
      block.down('#end_hour').setValue('');
    }
  },

  _updateBlockTotal: function (block) {
    let start_hour = block.down('#start_hour').getValue();
    let start_minute = block.down('#start_minute').getValue();
    let end_hour = block.down('#end_hour').getValue();
    let end_minute = block.down('#end_minute').getValue();

    block.down('#block_total').setValue(0);

    let total = 0;

    if (!Ext.isEmpty(start_hour) && !Ext.isEmpty(end_hour)) {
      let start = new Date(1999, 1, 1, start_hour, start_minute || 0);
      let end = new Date(1999, 1, 1, end_hour, end_minute || 0);
      total = Rally.util.DateTime.getDifference(end, start, 'minute') / 60;
    }

    block.down('#block_total').setValue(total);
    this._enableDisableAddButton();
  },

  _updateRow: function (block) {
    this.row.addTimeBlock(CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay], {
      id: block.getItemId(),
      start_hour: block.down('#start_hour').getValue(),
      start_minute: block.down('#start_minute').getValue(),
      end_hour: block.down('#end_hour').getValue(),
      end_minute: block.down('#end_minute').getValue()
    });

    this.row.save();
  },

  _enableDisableAddButton: function () {
    if (!this.down('#add_block_button')) {
      return;
    }

    let disabled = false;
    Ext.Array.each(this.timeBlocks, function (block) {
      if (!block.down('#block_total')) {
        return;
      }

      let total = block.down('#block_total').getValue() || 0;

      if (total <= 0) {
        disabled = true;
      }
    });

    this.down('#add_block_button').setDisabled(disabled);
  },

  _getTotal: function () {
    let total = 0;

    Ext.Array.each(this.timeBlocks, function (block) {
      if (!Ext.isEmpty(block)) {
        let value = (block.down('#block_total') && block.down('#block_total').getValue()) || 0;
        total += value;
      }
    });

    let adjustment_box = this.down('#adjustment_box');
    if (!Ext.isEmpty(adjustment_box)) {
      let adjustment = adjustment_box.getValue() || 0;
      total = total + adjustment;
    }

    return total;
  },

  _recalculateTotal: function () {
    let total = Ext.util.Format.number(this._getTotal(), '#.##');
    let day = CA.techservices.timesheet.TimeRowUtils.daysInOrder[this.currentDay];

    this.day_boxes[day].update({ day: day, value: total });

    this.row.set(day, parseFloat(total, 10));
    this.row.save();
  }
});

                Ext.define('CA.techservices.timesheet.TimeRowUtils', {
  singleton: true,

  daysInOrder: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],

  dayShortNames: { Sunday: 'Sun', Monday: 'Mon', Tuesday: 'Tues', Wednesday: 'Wed', Thursday: 'Thur', Friday: 'Fri', Saturday: 'Sat' },

  getDayOfWeekFromDate: function (jsdate) {
    if (jsdate.getUTCHours() === 0) {
      return jsdate.getUTCDay();
    }
    return jsdate.getDay();
  },

  detailKeyPrefix: 'ca.technicalservices.timesheet.details',

  getDetailPrefix: function (start_date) {
    if (Ext.isDate(start_date)) {
      start_date = Rally.util.DateTime.toIsoString(start_date).replace(/T.*$/, '');
    }
    return Ext.String.format('{0}.{1}', CA.techservices.timesheet.TimeRowUtils.detailKeyPrefix, start_date);
  },

  getDayOfWeek: function (value, record) {
    let week_start_date = record.get('WeekStartDate');
    if (Ext.isEmpty(week_start_date)) {
      return 0;
    }
    return CA.techservices.timesheet.TimeRowUtils.getDayOfWeekFromDate(week_start_date);
  },

  getFieldFromTimeEntryItems: function (value, record, field_name) {
    if (!Ext.isEmpty(value)) {
      return value;
    }

    let teis = record.get('TimeEntryItemRecords');
    if (Ext.isEmpty(teis)) {
      return value;
    }

    if (!Ext.isArray(teis) || teis.length === 0) {
      return value;
    }

    if (/\./.test(field_name)) {
      let field_array = field_name.split('.');
      let field = field_array.shift();
      if (field_array.length == 1) {
        if (Ext.isEmpty(teis[0].get(field))) {
          return null;
        }
        return teis[0].get(field)[field_array[0]];
      }
      if (field_array.length == 2) {
        if (Ext.isEmpty(teis[0].get(field)) || Ext.isEmpty(teis[0].get(field)[field_array[0]])) {
          return null;
        }
        return teis[0].get(field)[field_array[0]][field_array[1]];
      }

      console.log('Field Array Too Long', field_array);
    }
    return teis[0].get(field_name);
  },

  getDayValueFromTimeEntryValues: function (value, record, day_name) {
    // if we're modifying this directly, don't take it from the TimeEntryValueRecords
    if (!Ext.isEmpty(value)) {
      return value;
    }

    let index = Ext.Array.indexOf(CA.techservices.timesheet.TimeRowUtils.daysInOrder, day_name);
    let week_start_date = record.get('WeekStartDate');

    if (Ext.isEmpty(week_start_date)) {
      return 0;
    }

    let week_end_date = Rally.util.DateTime.add(week_start_date, 'week', 1);

    let time_entry_values = record.get('TimeEntryValueRecords');

    let day_value = 0;
    Ext.Array.each(time_entry_values, function (time_entry_value) {
      let tev_day = time_entry_value.get('DateVal').getUTCDay();
      let tev_date = time_entry_value.get('DateVal');

      if (tev_day == index && tev_date >= week_start_date && tev_date < week_end_date) {
        day_value = time_entry_value.get('Hours');
      }
    });

    return day_value || 0;
  },

  getTotalFromDayValues: function (value, record) {
    let total = 0;
    Ext.Array.each(CA.techservices.timesheet.TimeRowUtils.daysInOrder, function (day) {
      let hours = record.get(day) || 0;
      total = 100 * hours + total;
    });

    return Math.round(total) / 100;
  },

  getOrderedDaysBasedOnWeekStart: function (week_start_day) {
    if (week_start_day === 0) {
      return CA.techservices.timesheet.TimeRowUtils.daysInOrder;
    }

    let standard_days = CA.techservices.timesheet.TimeRowUtils.daysInOrder;

    let first_days = Ext.Array.slice(standard_days, week_start_day, 7);
    let second_days = Ext.Array.slice(standard_days, 0, week_start_day);

    return Ext.Array.push(first_days, second_days);
  },

  getValueFromDayOfWeek: function (week_start_date, week_start_day, day_name) {
    let days_in_order = CA.techservices.timesheet.TimeRowUtils.getOrderedDaysBasedOnWeekStart(week_start_day);

    let index = Ext.Array.indexOf(days_in_order, day_name);
    if (moment(week_start_date).hours() === 0) {
      return moment(week_start_date).add(index, 'days').toDate();
    }

    return moment(week_start_date).utc().add(index, 'days').toDate();
  },

  getBlocksFromDetailPreference: function (value, record) {
    if (!Ext.isEmpty(value)) {
      return value;
    }

    let pref = record.get('DetailPreference');
    if (Ext.isEmpty(pref)) {
      return {};
    }

    let pref_value = pref.get('Value');

    if (Ext.isEmpty(pref_value)) {
      return {};
    }
    if (!/{/.test(pref_value)) {
      return {};
    }

    return Ext.JSON.decode(pref_value);
  },

  getItemOIDFromTimeEntryItem: function (record) {
    let item_oid = -1;
    let workproduct = record.get('WorkProduct');
    let task = record.get('Task');

    if (!Ext.isEmpty(workproduct)) {
      item_oid = workproduct.ObjectID;
    }

    if (!Ext.isEmpty(task)) {
      item_oid = task.ObjectID;
    }

    return item_oid;
  },

  getDetailPreference: function (record) {
    return Deft.Chain.sequence([
      function () {
        let deferred = Ext.create('Deft.Deferred');
        if (!Ext.isEmpty(record.get('DetailPreference'))) {
          return [record.get('DetailPreference')];
        }

        let oid = record.get('TaskOID');
        if (oid < 0) {
          oid = record.get('WorkProductOID');
        }
        let key_start = CA.techservices.timesheet.TimeRowUtils.getDetailPrefix(record.get('WeekStartDate'));

        let key = Ext.String.format('{0}.{1}', key_start, oid);

        Rally.data.ModelFactory.getModel({
          type: 'Preference',
          success: function (model) {
            let pref = Ext.create(model, {
              Name: key,
              Value: '{}',
              User: Rally.getApp().getContext().getUser()._ref,
              Project: null
            });

            pref.save({
              callback: function (preference, operation) {
                if (operation.wasSuccessful()) {
                  record.set('DetailPreference', preference);
                  deferred.resolve(preference);
                }
              }
            });
          }
        });

        return deferred.promise;
      }
    ]);
  },

  loadWsapiRecords: function (config, returnOperation) {
    let deferred = Ext.create('Deft.Deferred');
    let me = this;

    let default_config = {
      model: 'Preference',
      fetch: ['ObjectID']
    };
    Ext.create('Rally.data.wsapi.Store', Ext.Object.merge(default_config, config)).load({
      callback: function (records, operation, successful) {
        if (successful) {
          if (returnOperation) {
            deferred.resolve(operation);
          } else {
            deferred.resolve(records);
          }
        } else {
          deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
        }
      }
    });
    return deferred.promise;
  }
});

Ext.define('CA.techservices.timesheet.TimeRow', {
  extend: 'Ext.data.Model',

  createTEVProcess: {},

  fields: [
    { name: '__SecretKey', type: 'string' },
    { name: 'Pinned', type: 'boolean', defaultValue: false },
    {
      name: 'Project',
      type: 'object',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Project');
      }
    },

    {
      name: 'Task',
      type: 'object',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task') || '';
      }
    },
    {
      name: 'TaskOID',
      type: 'number',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task');

        if (Ext.isEmpty(item)) {
          return -1;
        }
        return item.ObjectID || -1;
      }
    },
    {
      name: 'TaskFID',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task');

        if (Ext.isEmpty(item)) {
          return -1;
        }
        return item.FormattedID || -1;
      }
    },
    {
      name: 'TaskName',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task');

        if (Ext.isEmpty(item)) {
          return '';
        }
        return item.Name || '';
      }
    },
    {
      name: 'User',
      type: 'object',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'User');
      }
    },
    { name: 'WeekStartDate', type: 'date' },
    {
      name: 'WorkProduct',
      type: 'object',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct') || '';
      }
    },
    {
      name: 'WorkProductOID',
      type: 'number',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct');

        if (Ext.isEmpty(item)) {
          return -1;
        }
        return item.ObjectID || -1;
      }
    },
    {
      name: 'WorkProductFID',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct');

        if (Ext.isEmpty(item)) {
          return '';
        }
        return item.FormattedID || '';
      }
    },
    {
      name: 'WorkProductName',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct');

        if (Ext.isEmpty(item)) {
          return '';
        }
        return item.Name || '';
      }
    },
    {
      name: 'WorkProductState',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.State') || '--';

        //                if ( Ext.isEmpty(item) ) { return ''; }
        //                return item.State || '';
      }
    },
    {
      name: 'WorkProductPriority',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        return (
          CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.Priority') ||
          CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.c_Priority')
        );

        //                if ( Ext.isEmpty(item) ) { return ''; }
        //                return item.Priority || '';
      }
    },
    {
      name: 'PortfolioItem',
      type: 'object',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.PortfolioItem') || '';
      }
    },
    {
      name: 'PortfolioItemOID',
      type: 'number',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.PortfolioItem');

        if (Ext.isEmpty(item)) {
          return -1;
        }
        return item.ObjectID || -1;
      }
    },
    {
      name: 'PortfolioItemFID',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.PortfolioItem');

        if (Ext.isEmpty(item)) {
          return '';
        }
        return item.FormattedID || '';
      }
    },
    {
      name: 'PortfolioItemName',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        let item = CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.PortfolioItem');

        if (Ext.isEmpty(item)) {
          return '';
        }
        return item.Name || '';
      }
    },

    {
      name: 'Release',
      type: 'string',
      defaultValue: null,
      convert: function (value, record) {
        return (
          CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.Release') ||
          CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task.Release') ||
          ''
        );
      }
    },

    {
      name: 'Iteration',
      type: 'object',
      defaultValue: null,
      convert: function (value, record) {
        return (
          CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'WorkProduct.Iteration') ||
          CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task.Iteration') ||
          ''
        );
      }
    },

    {
      name: 'ToDo',
      type: 'number',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task.ToDo');
      }
    },

    {
      name: 'Est',
      type: 'number',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task.Estimate');
      }
    },

    {
      name: 'State',
      type: 'object',
      defaultValue: null,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getFieldFromTimeEntryItems(value, record, 'Task.State') || '';
      },
      sortType: function (value) {
        let allowed_order = ['Defined', 'In-Progress', 'Completed'];
        return Ext.Array.indexOf(allowed_order, value);
      }
    },
    // WeekStart: Day of Week (0=Sunday, 6=Saturday)
    { name: 'WeekStart', type: 'int', convert: CA.techservices.timesheet.TimeRowUtils.getDayOfWeek },

    // store the AC records for saving/updating
    { name: 'TimeEntryItemRecords', type: 'object', defaultValue: [] },
    { name: 'TimeEntryValueRecords', type: 'object', defaultValue: [] },

    //
    {
      name: 'Sunday',
      type: 'number',
      persist: true,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getDayValueFromTimeEntryValues(value, record, 'Sunday');
      }
    },
    {
      name: 'Monday',
      type: 'number',
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getDayValueFromTimeEntryValues(value, record, 'Monday');
      }
    },
    {
      name: 'Tuesday',
      type: 'number',
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getDayValueFromTimeEntryValues(value, record, 'Tuesday');
      }
    },
    {
      name: 'Wednesday',
      type: 'number',
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getDayValueFromTimeEntryValues(value, record, 'Wednesday');
      }
    },
    {
      name: 'Thursday',
      type: 'number',
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getDayValueFromTimeEntryValues(value, record, 'Thursday');
      }
    },
    {
      name: 'Friday',
      type: 'number',
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getDayValueFromTimeEntryValues(value, record, 'Friday');
      }
    },
    {
      name: 'Saturday',
      type: 'number',
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getDayValueFromTimeEntryValues(value, record, 'Saturday');
      }
    },
    {
      name: 'Total',
      type: 'number',
      defaultValue: 0,
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getTotalFromDayValues(value, record);
      }
    },
    {
      name: 'DetailPreference',
      type: 'object',
      defaultValue: null
    },
    {
      name: '_DetailBlocks',
      type: 'object',
      convert: function (value, record) {
        return CA.techservices.timesheet.TimeRowUtils.getBlocksFromDetailPreference(value, record);
      }
    }
  ],

  getWeekStartDates: function () {
    let day_of_week = this.get('WeekStart');
    let date_of_week = this.get('WeekStartDate');

    if (day_of_week === 0) {
      return [date_of_week];
    }

    let date1 = Rally.util.DateTime.add(date_of_week, 'day', -1 * day_of_week);
    let date2 = Rally.util.DateTime.add(date1, 'day', 7);

    return [date1, date2];
  },

  save: function (v) {
    let me = this;
    let changes = this.getChanges();
    let promises = [];
    // let week_start_date = this.get('WeekStartDate');

    Ext.Object.each(changes, function (field, value) {
      let value_date = CA.techservices.timesheet.TimeRowUtils.getValueFromDayOfWeek(me.get('WeekStartDate'), me.get('WeekStart'), field);
      //if ( value_date > new Date() ) { Rally.ui.notify.Notifier.showWarning({message: 'Warning: Creating Time in Future', timeout: 1000});  }

      if (Ext.Array.contains(CA.techservices.timesheet.TimeRowUtils.daysInOrder, field)) {
        if (me._dateIsPrecedingMonth(value_date) || me._dateIsPrecedingWeek(value_date)) {
          me._showClosedNotification();
        }
        promises.push(function () {
          return me._changeDayValue(field, value);
        });
      }

      if (field === 'ToDo') {
        promises.push(function () {
          return me._changeToDoValue(value);
        });
      }

      if (field == 'State') {
        promises.push(function () {
          return me._changeStateValue(value);
        });
      }

      if (field === '_DetailBlocks') {
        promises.push(function () {
          return me._changeDetailPreference(value);
        });
      }

      if (field === 'WorkProductState') {
        promises.push(function () {
          return me._changeDefectStateValue(value);
        });
      }
    });

    return Deft.Chain.sequence(promises, this);
  },

  _showClosedNotification: function () {
    Rally.ui.notify.Notifier.showWarning({ message: 'Warning: Creating time entry in a closed period - registrations will not be transferred to SAP' });
    setTimeout(function () {
      Rally.ui.notify.Notifier.hide();
    }, 6000);
  },

  _changeToDoValue: function (value) {
    return this._changeTaskFieldValue('ToDo', value);
  },

  _changeStateValue: function (value) {
    if (value === 'Completed') {
      this.set('ToDo', 0);
    }

    return this._changeTaskFieldValue('State', value);
  },

  _changeTaskFieldValue: function (field, value) {
    let deferred = Ext.create('Deft.Deferred'),
      me = this;
    let task = this.get('Task');

    if (Ext.isEmpty(task)) {
      return;
    }

    Rally.data.ModelFactory.getModel({
      type: 'Task',
      scope: this,
      success: function (model) {
        model.load(task.ObjectID, {
          fetch: ['Name', 'State', 'Iteration', 'ToDo', 'WorkProduct'],
          callback: function (result, operation) {
            if (operation.wasSuccessful()) {
              result.set(field, value);
              result.save({
                callback: function (new_task, operation) {
                  me.set('Task', new_task.getData());
                  deferred.resolve(new_task);
                }
              });
            } else {
              deferred.reject('Problem saving Task');
            }
          }
        });
      }
    });
    return deferred;
  },

  _changeDefectStateValue: function (value) {
    return this._changeDefectFieldValue('State', value);
  },

  _changeDefectFieldValue: function (field, value) {
    let deferred = Ext.create('Deft.Deferred'),
      me = this;
    let defect = this.get('WorkProduct');

    if (Ext.isEmpty(defect)) {
      return;
    }

    Rally.data.ModelFactory.getModel({
      type: 'Defect',
      scope: this,
      success: function (model) {
        model.load(defect.ObjectID, {
          fetch: ['Name', 'State'],
          callback: function (result, operation) {
            if (operation.wasSuccessful()) {
              result.set(field, value);
              result.save({
                callback: function (new_defect, operation) {
                  me.set('Defect', new_defect.getData());
                  deferred.resolve(new_defect);
                }
              });
            } else {
              deferred.reject('Problem saving Defect');
            }
          }
        });
      }
    });
    return deferred;
  },

  _changeDayValue: function (day, value) {
    let deferred = Ext.create('Deft.Deferred'),
      me = this;

    let time_entry_value = this.getTimeEntryValue(day);

    // remove from cache of fields that have changed (assumes save is fine)
    delete this.modified[day];

    if (Ext.isEmpty(time_entry_value)) {
      return this._createTimeEntryValue(day, value);
    }

    time_entry_value.set('Hours', value);
    // recalculate total
    this.set('Total', 0);

    time_entry_value.save({
      callback: function (result) {
        deferred.resolve(result);
      }
    });

    return deferred.promise;
  },

  clearAndRemove: function () {
    let me = this,
      promises = [];

    Rally.getApp().setLoading('Clearing...');

    Ext.Array.each(CA.techservices.timesheet.TimeRowUtils.daysInOrder, function (day_name) {
      let time_entry_value = me.getTimeEntryValue(day_name);

      if (!Ext.isEmpty(time_entry_value)) {
        promises.push(function () {
          let deferred = Ext.create('Deft.Deferred');
          me.set(day_name, 0);
          time_entry_value.destroy({
            callback: function (result, operation) {
              deferred.resolve();
            }
          });
          return deferred.promise;
        });
      }
    });

    Deft.Chain.sequence(promises).then({
      scope: this,
      success: function (results) {
        this.set('TimeEntryValueRecords', []);
        this.set('Total', 0);

        let time_entry_items = this.get('TimeEntryItemRecords');
        let promises = Ext.Array.map(time_entry_items, function (time_entry_item) {
          return function () {
            return me._removeTimeEntryItem(time_entry_item);
          };
        });

        Deft.Chain.sequence(promises)
          .then({
            scope: this,
            success: function () {
              Rally.getApp().setLoading(false);
              me.destroy();
            },
            failure: function (msg) {
              console.log("cannot remove all the time entry items because they're used elsewhere", msg);
            }
          })
          .always(function () {
            Rally.getApp().setLoading(false);
          });
      }
    });
  },

  _removeTimeEntryItem: function (time_entry_value) {
    let deferred = Ext.create('Deft.Deferred');
    time_entry_value.destroy({
      callback: function (result, operation) {
        if (operation.wasSuccessful()) {
          deferred.resolve();
        } else {
          deferred.reject(operation.error.errors[0]);
        }
      }
    });
    return deferred.promise;
  },

  getTimeEntryValue: function (day_name) {
    let index = Ext.Array.indexOf(CA.techservices.timesheet.TimeRowUtils.daysInOrder, day_name);
    let week_start_date = this.get('WeekStartDate');
    let time_entry_values = this.get('TimeEntryValueRecords');
    let day_value = null;
    let value_date = CA.techservices.timesheet.TimeRowUtils.getValueFromDayOfWeek(this.get('WeekStartDate'), this.get('WeekStart'), day_name);

    Ext.Array.each(time_entry_values, function (time_entry_value) {
      if (Ext.Date.format(value_date, 'y-m-d') === Ext.Date.format(time_entry_value.get('DateVal'), 'y-m-d')) {
        day_value = time_entry_value;
      }
    });

    return day_value;
  },

  _createTimeEntryValue: function (day_name, value) {
    let deferred = Ext.create('Deft.Deferred'),
      me = this;
    let value_date = CA.techservices.timesheet.TimeRowUtils.getValueFromDayOfWeek(this.get('WeekStartDate'), this.get('WeekStart'), day_name);
    let time_entry_item = null;
    Ext.Array.each(this.get('TimeEntryItemRecords'), function (item) {
      let delta = Rally.util.DateTime.getDifference(value_date, item.get('WeekStartDate'), 'day');
      if (value_date >= item.get('WeekStartDate') && delta < 7) {
        time_entry_item = item;
      }
    });

    if (Ext.isEmpty(time_entry_item)) {
      console.log('No Time Entry Item');

      this._createTimeEntryItem(value_date, this.get('Project'), this.get('WorkProduct'), this.get('Task')).then({
        scope: this,
        success: function (result) {
          if (this.createTEVProcess[day_name] && this.createTEVProcess[day_name].getState() === 'pending') {
            console.log('..Save is already in process');
            deferred.resolve();
          } else {
            this.createTEVProcess[day_name] = this._createTimeEntryValueWithModel(day_name, value, value_date, result);
            return this.createTEVProcess[day_name];
          }
        },
        failure: function (msg) {
          console.log('Problem creating new TEI', msg);
          deferred.reject(msg);
        }
      });
      return deferred.promise;
    }

    if (this.createTEVProcess[day_name] && this.createTEVProcess[day_name].getState() === 'pending') {
      console.log('...Save is already in process', day_name);
      return;
    } else {
      this.createTEVProcess[day_name] = this._createTimeEntryValueWithModel(day_name, value, value_date, time_entry_item);
      return this.createTEVProcess[day_name];
    }
  },

  _createTimeEntryItem: function (value_date, project, workproduct, task) {
    Rally.getApp().setLoading('Creating Time Entry Item...');

    let deferred = Ext.create('Deft.Deferred'),
      me = this;

    let sunday_start = TSDateUtils.getBeginningOfWeekISOForLocalDate(value_date);

    let config = {
      WeekStartDate: sunday_start,
      Project: { _ref: project._ref }
    };

    if (!Ext.isEmpty(task)) {
      config.Task = { _ref: task._ref };
    }

    if (!Ext.isEmpty(workproduct)) {
      config.WorkProduct = { _ref: workproduct._ref };
    }

    Rally.data.ModelFactory.getModel({
      type: 'TimeEntryItem',
      scope: this,
      success: function (model) {
        let tei = Ext.create(model, config);
        tei.save({
          callback: function (result) {
            let records = me.get('TimeEntryItemRecords') || [];
            records.push(result);
            me.set('TimeEntryItemRecords', records);
            Rally.getApp().setLoading(false);
            deferred.resolve(result);
          }
        });
      }
    });
    return deferred.promise;
  },

  _createTimeEntryValueWithModel: function (day_name, value, value_date, time_entry_item) {
    let deferred = Ext.create('Deft.Deferred'),
      me = this;

    let date_val = TSDateUtils.formatShiftedDate(value_date, 'Y-m-d') + 'T00:00:00.000Z';

    Rally.data.ModelFactory.getModel({
      type: 'TimeEntryValue',
      scope: this,
      success: function (model) {
        this._changeFieldRights(model);

        let tev = Ext.create(model, {
          Hours: value,
          TimeEntryItem: { _ref: time_entry_item.get('_ref') },
          DateVal: date_val
        });

        tev.save({
          callback: function (result, operation) {
            if (operation.wasSuccessful()) {
              this.set(day_name, value);

              let records = me.get('TimeEntryValueRecords') || [];
              records.push(result);
              me.set('TimeEntryValueRecords', records);

              me.set('Total', 0); // updates the total automatically
              deferred.resolve(result);
            } else {
              me.set(day_name, 0);
              console.log('Problem saving Time Entry Value:', day_name, operation);
              //throw 'Problem saving time entry value';
              deferred.reject(operation.error && operation.error.errors.join('.'));
            }
          }
        });
      }
    });
    return deferred.promise;
  },

  _changeFieldRights: function (model) {
    let fields = model.getFields();
    Ext.Array.each(fields, function (field, idx) {
      if (field.name === 'TimeEntryItem') {
        field.readOnly = false;
        field.persist = true;
        field.type = 'string';
      }
      if (field.name === 'DateVal') {
        // override field definition so that we can write to the
        // field AND pass it a string for midnight at Z instead of
        // the local timestamp
        fields[idx] = Ext.create('Rally.data.wsapi.Field', {
          type: 'string',
          readOnly: false,
          persist: true,
          name: 'DateVal',
          custom: false,
          hidden: false,
          useNull: false
        });
      }
    });

    return model;
  },

  _changeDetailPreference: function (value) {
    let me = this;
    let json_value = Ext.JSON.encode(value);

    if (this.process && this.process.getState() === 'pending') {
      return;
    }

    this.process = Deft.Chain.sequence(
      [
        function () {
          return CA.techservices.timesheet.TimeRowUtils.getDetailPreference(me);
        }
      ],
      this
    ).then({
      success: function (preferences) {
        preferences = Ext.Array.flatten(preferences);
        if (preferences.length === 0) {
          return;
        }
        let preference = preferences[0];

        preference.set('Value', json_value);
        preference.save();
      },
      failure: function (msg) {
        Ext.Msg.alert('Problem saving detail', msg);
      }
    });
  },

  addTimeBlock: function (day, time_object) {
    let block_set = this.get('_DetailBlocks');
    if (Ext.isEmpty(block_set) && !Ext.isEmpty(this.get('DetailPreference'))) {
      block_set = Ext.JSON.decode(this.get('DetailPreference').get('Value'));
      this.set('_DetailBlocks', block_set);
    }

    let blocks = this.getTimeBlocks(day);

    let block = this.getTimeBlock(day, time_object.id);
    if (Ext.isEmpty(block)) {
      blocks.push(time_object);
      //block_set[day] = blocks;
    } else {
      Ext.Object.merge(block, time_object);
    }

    block_set[day] = blocks;

    this.set('_DetailBlocks', block_set);
    this.set('_SecretKey', new Date());
    this.setDirty(); // TODO: why is set() not setting the record as dirty and the field as changed?
  },

  removeTimeBlock: function (day, block_id) {
    let block_set = this.get('_DetailBlocks');
    if (Ext.isEmpty(block_set) && !Ext.isEmpty(this.get('DetailPreference'))) {
      block_set = Ext.JSON.decode(this.get('DetailPreference').get('Value'));
      this.set('_DetailBlocks', block_set);
    }

    let blocks = this.getTimeBlocks(day);

    let new_blocks = Ext.Array.filter(blocks, function (block) {
      return block_id !== block.id;
    });

    block_set[day] = new_blocks;

    this.set('_DetailBlocks', block_set);
    this.set('_SecretKey', new Date());
    this.setDirty(); // TODO: why is set() not setting the record as dirty and the field as changed?
  },

  getTimeBlock: function (day, id) {
    let blocks = this.getTimeBlocks(day);
    let block = null;
    Ext.Array.each(blocks, function (b) {
      if (b.id === id) {
        block = b;
      }
    });

    return block;
  },

  getTimeBlocks: function (day) {
    let blocks = this.get('_DetailBlocks');

    if (blocks && blocks[day]) {
      return blocks[day];
    }
    return [];
  },

  isPinned: function () {
    return this.get('Pinned') || false;
  },

  _dateIsPrecedingWeek: function () {
    let today = new Date();
    let week_start_date = this.get('WeekStartDate');
    if (today < week_start_date) {
      return false;
    }

    if (today > Rally.util.DateTime.add(week_start_date, 'day', 8)) {
      return true;
    }
    // if this is the first day of the following week, ok if it's before 12:05
    if (today > Rally.util.DateTime.add(week_start_date, 'day', 7) && today < Rally.util.DateTime.add(week_start_date, 'day', 8)) {
      if (today.getHours() > 12) {
        return true;
      }

      if (today.getHours() === 12 && today.getMinutes() > 4) {
        return true;
      }
    }

    return false;
  },

  _dateIsPrecedingMonth: function (value_date) {
    let today = new Date();
    // if we're in next year or next month, it's not preceding month
    if (value_date.getYear() > today.getYear() || value_date.getMonth() > today.getMonth()) {
      return false;
    }

    // if we're the same month, it's not the preceding month
    if (value_date.getMonth() === today.getMonth()) {
      return false;
    }
    // if we're putting in data for the month before last, it's definitely
    // old
    if (value_date.getMonth() < today.getMonth() - 1) {
      return true;
    }
    // if we're putting in data and today is the first, it might be ok for last month
    if (today.getDate() > 1) {
      return true;
    }
    // if it's the first of the month, we have until 12:05pm
    if (today.getHours() > 12) {
      return true;
    }

    if (today.getHours() === 12 && today.getMinutes() > 5) {
      return true;
    }
    return false;
  },

  hasOpenDetails: function () {
    let has_open = false;
    let blocks = this.get('_DetailBlocks');

    Ext.Object.each(blocks, function (day, day_blocks) {
      Ext.Array.each(day_blocks, function (block) {
        if (Ext.isEmpty(block.end_hour)) {
          has_open = true;
        }
      });
    });

    return has_open;
  }
});

                Ext.override(Rally.ui.grid.plugin.Validation, {
  _onBeforeEdit: function () {
    // clear this because it won't let us do the getEditor on cells
  }
});

Ext.define('CA.techservices.TimeTable', {
  extend: 'Ext.Container',
  alias: 'widget.tstimetable',
  rows: [],
  cls: 'tstimetable',

  time_entry_item_fetch: [
    'WeekStartDate',
    'WorkProductDisplayString',
    'WorkProduct',
    'Task',
    'TaskDisplayString',
    'PortfolioItem',
    'Project',
    'ObjectID',
    'Name',
    'Release',
    'FormattedID',
    'Iteration',
    'ToDo',
    'State',
    'Rank',
    'Defect',
    'Estimate',
    'Priority',
    'c_Priority'
  ],

  config: {
    startDate: null,
    editable: true,
    timesheetUser: null,
    pinKey: 'CA.techservices.timesheet.pin',
    showEditTimeDetailsMenuItem: false,
    pickableColumns: null,
    maxRows: null,
    /* String -- put in the lowest level PI Name (field name on a story) so we can trace up to a PI */
    lowestLevelPIName: null
  },

  constructor: function (config) {
    this.mergeConfig(config);

    if (Ext.isEmpty(config.startDate) || !Ext.isDate(config.startDate)) {
      throw 'CA.techservices.TimeTable requires startDate parameter (JavaScript Date)';
    }

    this.weekStart = CA.techservices.timesheet.TimeRowUtils.getDayOfWeekFromDate(this.startDate) || 0;
    this.callParent([this.config]);
  },

  initComponent: function () {
    this.callParent(arguments);

    this.addEvents(
      /**
       * @event
       * Fires when the grid has been rendered
       * @param {CA.techservices.TimeTable } this
       * @param {Rally.ui.grid.Grid} grid
       */
      'gridReady'
    );

    if (Ext.isEmpty(this.timesheetUser)) {
      this.timesheetUser = Rally.getApp().getContext().getUser();
    }
    // shift start date
    this.startDate = TSDateUtils.pretendIMeantUTC(this.startDate);

    if (!Ext.isEmpty(this.lowestLevelPIName)) {
      this.time_entry_item_fetch.push(this.lowestLevelPIName);
    }

    TSUtilities.fetchField('Task', 'State').then({
      success: function (field) {
        this.taskState = field;
        this._updateData();
      },
      failure: function (msg) {
        Ext.Msg.alert('Problem Initiating TimeSheet App', msg);
      },
      scope: this
    });
  },

  _updateData: function () {
    this.setLoading('Loading time...');
    let me = this;
    me.maxRows = 48;

    Deft.Chain.sequence([this._loadTimeEntryItems, this._loadTimeEntryValues, this._loadTimeDetailPreferences, this._loadDefaultSettings], this).then({
      scope: this,
      success: function (results) {
        let time_entry_items = results[0];
        let time_entry_values = results[1];
        let time_detail_prefs = results[2];
        this.time_entry_defaults = results[3];

        this.rows = this._createRows(time_entry_items, time_entry_values, time_detail_prefs);
        this._makeGrid(this.rows);
        this.setLoading(false);
      },
      failure: function (msg) {
        Ext.Msg.alert('Problem Loading', msg);
      }
    });
  },

  _loadDefaultSettings: function () {
    let deferred = Ext.create('Deft.Deferred');

    Rally.data.PreferenceManager.load({
      filterByUser: true,
      additionalFilters: [{ property: 'Name', operator: 'contains', value: this.pinKey }],

      success: function (prefs) {
        //process prefs
        let defaults = {};
        Ext.Object.each(prefs, function (key, pref) {
          let value = Ext.JSON.decode(pref);
          Ext.apply(defaults, value);
        });

        deferred.resolve(defaults);
      }
    });
    return deferred.promise;
  },

  _makeGrid: function (rows) {
    this.removeAll();
    let me = this,
      table_store = Ext.create('Rally.data.custom.Store', {
        model: 'CA.techservices.timesheet.TimeRow',
        data: rows,
        pageSize: me.maxRows,
        remoteSort: false,
        sortOnFither: true,
        sortOnLoad: true,
        sorters: [{ property: this.sortedColumn, direction: this.sortDirection }]
      });

    this.grid = this.add({
      xtype: 'rallygrid',
      store: table_store,
      columnCfgs: this._getColumns(),
      showPagingToolbar: false,
      showRowActionsColumn: false,
      disableSelection: true,
      enableColumnMove: false,
      enableColumnResize: false,
      features: [
        {
          ftype: 'summary',
          dock: 'top'
        }
      ],
      listeners: {
        sortchange: function (ct, column, direction) {
          this.sortedColumn = column.dataIndex;
          this.sortDirection = direction;
          me.fireEvent('sortchange', this, column.dataIndex, direction);
        }
      },
      viewConfig: {
        listeners: {
          itemupdate: function () {}
        }
      }
    });

    this.fireEvent('gridReady', this, this.grid);
  },

  _getRowActions: function (record) {
    //
    let me = this;

    let actions = [
      {
        xtype: 'rallyrecordmenuitem',
        text: 'Set as Default',
        predicate: function () {
          return !this.record.isPinned();
        },
        handler: function (menu) {
          me._pinRecord(menu.record);
        },
        record: record
      },
      {
        xtype: 'rallyrecordmenuitem',
        text: 'Unset Default',
        predicate: function () {
          return this.record.isPinned();
        },
        handler: function (menu) {
          me._unpinRecord(menu.record);
        },
        record: record
      },
      {
        xtype: 'rallyrecordmenuitem',
        text: 'Clear',
        record: record,
        handler: function (menu) {
          let row = menu.record;
          if (0 < row.get('Total')) {
            Ext.MessageBox.confirm('Clear Row', 'You have hours entered for this row. Are you sure?', function (res) {
              if ('yes' === res) {
                Ext.Array.remove(me.rows, row);
                row.clearAndRemove();
              }
            });
          } else {
            Ext.Array.remove(me.rows, row);
            row.clearAndRemove();
          }
        }
      }
    ];

    if (me.showEditTimeDetailsMenuItem) {
      actions.push({
        xtype: 'rallyrecordmenuitem',
        text: 'Edit Time',
        record: record,
        handler: function (menu) {
          let row = menu.record;
          me._launchTimeDetailsDialog(row);
        }
      });
    }
    return actions;
  },

  setPickableColumns: function (pickable_columns) {
    let columns = Ext.Array.merge([], this._getBaseLeftColumns());
    columns = Ext.Array.merge(columns, pickable_columns);
    columns = Ext.Array.merge(columns, this._getBaseRightColumns());

    let store = this.getGrid().getStore();
    this.getGrid().reconfigure(store, columns);
  },

  _getColumns: function () {
    let columns = Ext.Array.merge([], this._getBaseLeftColumns());

    columns = Ext.Array.merge(columns, this.getPickableColumns());

    columns = Ext.Array.merge(columns, this._getBaseRightColumns());

    return columns;
  },

  getRankValue: function (record, gridStore) {
    let store = (gridStore && gridStore.treeStore) || gridStore,
      sorters = store && store.getSorters(),
      sorter = sorters && sorters[1];

    if (sorter && Rally.data.Ranker.isRankField(sorter.property)) {
      let index = store.indexOf(record);
      if (index !== -1) {
        let currentPage = store.currentPage ? store.currentPage : 1;
        let offset = store.pageSize * (currentPage - 1);

        return sorter.direction === 'ASC' ? index + offset + 1 : store.getTotalCount() - offset - index;
      }
    }
    return '';
  },

  getPickableColumns: function () {
    let columns = [],
      me = this;

    columns.push({
      dataIndex: 'Project',
      text: 'Project',
      flex: 1,
      editor: null,
      sortable: true,
      hidden: false,
      menuDisabled: true,
      renderer: function (value, meta, record) {
        if (value < 0) {
          return '--';
        }
        return record.get('Project').Name;
      }
    });

    columns.push({
      dataIndex: 'WorkProductOID',
      text: 'Work Item',
      flex: 1,
      editor: null,
      sortable: true,
      menuDisabled: true,
      renderer: function (value, meta, record) {
        if (value < 0) {
          return '--';
        }
        return Ext.String.format(
          "<a target='_top' href='{0}'>{1}</a>: {2}",
          Rally.nav.Manager.getDetailUrl(record.get('WorkProduct')),
          record.get('WorkProduct').FormattedID,
          record.get('WorkProduct').Name
        );
      }
    });

    columns.push({
      dataIndex: 'WorkProductFID',
      text: 'Work Item ID',
      flex: 1,
      editor: null,
      hidden: true,
      menuDisabled: true,
      sortable: true,
      renderer: function (value, meta, record) {
        if (value < 0) {
          return '--';
        }
        return Ext.String.format("<a target='_top' href='{0}'>{1}</a>", Rally.nav.Manager.getDetailUrl(record.get('WorkProduct')), record.get('WorkProduct').FormattedID);
      }
    });

    columns.push({
      dataIndex: 'WorkProductName',
      text: 'Work Item Name',
      hidden: true,
      flex: 1,
      editor: null,
      menuDisabled: true,
      sortable: true
    });

    let d_state_config = {
      dataIndex: 'WorkProductState',
      text: 'Defect State',
      sortable: true,
      field: 'WorkProduct',
      menuDisabled: true,

      getEditor: function (record) {
        if (record.get('WorkProduct')._type !== 'Defect') {
          return false;
        }

        return Ext.create('Ext.grid.CellEditor', {
          field: Ext.create('Rally.ui.combobox.FieldValueComboBox', {
            xtype: 'rallyfieldvaluecombobox',
            model: 'Defect',
            field: 'State',
            value: record.get('WorkProduct').State,
            listeners: {
              change: function (field, new_value) {
                if (Ext.isEmpty(new_value)) {
                  return;
                }
                record.set('WorkProduct'.State, new_value);
                record.save();
              }
            }
          })
        });
      }
    };

    columns.push(d_state_config);

    if (Ext.isEmpty(this.lowestLevelPIName)) {
      columns.push({
        dataIndex: 'PortfolioItemOID',
        text: 'Portfolio Item',
        flex: 1,
        editor: null,
        sortable: true,
        hidden: true,
        menuDisabled: true,
        renderer: function (value, meta, record) {
          if (value < 0) {
            return '--';
          }
          return Ext.String.format(
            "<a target='_top' href='{0}'>{1}</a>: {2}",
            Rally.nav.Manager.getDetailUrl(record.get('PortfolioItem')),
            record.get('PortfolioItem').FormattedID,
            record.get('PortfolioItem').Name
          );
        }
      });

      columns.push({
        dataIndex: 'PortfolioItemFID',
        text: 'Portfolio Item ID',
        flex: 1,
        editor: null,
        hidden: true,
        menuDisabled: true,
        sortable: true,
        renderer: function (value, meta, record) {
          if (value < 0) {
            return '--';
          }
          return Ext.String.format("<a target='_top' href='{0}'>{1}</a>", Rally.nav.Manager.getDetailUrl(record.get('PortfolioItem')), record.get('PortfolioItem').FormattedID);
        }
      });

      columns.push({
        dataIndex: 'PortfolioItemName',
        text: 'PortfolioItem Name',
        hidden: true,
        flex: 1,
        editor: null,
        menuDisabled: true,
        sortable: true
      });
    } else {
      columns.push({
        dataIndex: 'PortfolioItemOID',
        text: this.lowestLevelPIName,
        flex: 1,
        editor: null,
        sortable: true,
        hidden: true,
        menuDisabled: true,
        renderer: function (value, meta, record) {
          if (value < 0) {
            return '--';
          }
          return Ext.String.format(
            "<a target='_top' href='{0}'>{1}</a>: {2}",
            Rally.nav.Manager.getDetailUrl(record.get('PortfolioItem')),
            record.get('PortfolioItem').FormattedID,
            record.get('PortfolioItem').Name
          );
        }
      });

      columns.push({
        dataIndex: 'PortfolioItemFID',
        text: this.lowestLevelPIName + ' ID',
        flex: 1,
        editor: null,
        hidden: true,
        menuDisabled: true,
        sortable: true,
        renderer: function (value, meta, record) {
          if (value < 0) {
            return '--';
          }
          return Ext.String.format("<a target='_top' href='{0}'>{1}</a>", Rally.nav.Manager.getDetailUrl(record.get('PortfolioItem')), record.get('PortfolioItem').FormattedID);
        }
      });

      columns.push({
        dataIndex: 'PortfolioItemName',
        text: this.lowestLevelPIName + ' Name',
        hidden: true,
        flex: 1,
        editor: null,
        menuDisabled: true,
        sortable: true
      });
    }

    columns.push({
      dataIndex: 'Release',
      text: 'Release',
      width: 150,
      editor: null,
      sortable: false,
      menuDisabled: true,
      renderer: function (value) {
        if (Ext.isEmpty(value)) {
          return '--';
        }
        return value._refObjectName;
      }
    });

    columns.push({
      dataIndex: 'Iteration',
      text: 'Iteration',
      width: 150,
      editor: null,
      sortable: false,
      menuDisabled: true,
      renderer: function (value) {
        if (Ext.isEmpty(value)) {
          return '--';
        }
        return value._refObjectName;
      }
    });

    columns.push({
      dataIndex: 'TaskOID',
      text: 'Task',
      sortable: true,
      flex: 1,
      menuDisabled: true,
      editor: null,
      renderer: function (value, meta, record) {
        if (value < 0) {
          return '--';
        }
        return Ext.String.format("<a target='_top' href='{0}'>{1}</a>: {2}", Rally.nav.Manager.getDetailUrl(record.get('Task')), record.get('Task').FormattedID, record.get('Task').Name);
      }
    });

    columns.push({
      dataIndex: 'TaskFID',
      text: 'Task ID',
      sortable: true,
      flex: 1,
      hidden: true,
      menuDisabled: true,
      editor: null,
      renderer: function (value, meta, record) {
        if (value < 0) {
          return '--';
        }
        return Ext.String.format("<a target='_top' href='{0}'>{1}</a>", Rally.nav.Manager.getDetailUrl(record.get('Task')), record.get('Task').FormattedID);
      }
    });

    columns.push({
      dataIndex: 'TaskName',
      text: 'Task Name',
      sortable: true,
      flex: 1,
      hidden: true,
      menuDisabled: true,
      editor: null
    });

    let state_config = {
      dataIndex: 'State',
      text: 'State',
      resizable: false,
      align: 'left',
      field: 'test',
      sortable: true,
      menuDisabled: true,

      getEditor: function (record) {
        if (Ext.isEmpty(record.get('Task'))) {
          return false;
        }

        return Ext.create('Ext.grid.CellEditor', {
          field: Ext.create('Rally.ui.combobox.FieldValueComboBox', {
            xtype: 'rallyfieldvaluecombobox',
            model: 'Task',
            field: 'State',
            value: record.get('Task').State,
            listeners: {
              change: function (field, new_value) {
                if (Ext.isEmpty(new_value)) {
                  return;
                }
                record.set('State', new_value);
                record.save();
              }
            }
          })
        });
      },
      renderer: function (value, metaData, record) {
        if (Ext.isEmpty(record.get('Task'))) {
          return '--';
        }
        let tpl = Ext.create('Rally.ui.renderer.template.ScheduleStateTemplate', { field: me.taskState });
        return tpl.apply(record.get('Task'));
      }
    };

    columns.push(state_config);

    // columns.push({
    //   dataIndex: 'Est',
    //   text: 'Estimate',
    //   sortable: true,
    //   width: 50,
    //   hidden: true,
    //   menuDisabled: true,
    //   editor: null
    // });

    let todo_config = {
      dataIndex: 'ToDo',
      text: 'To Do',
      width: 50,
      resizable: false,
      align: 'center',
      field: 'test',
      sortable: true,
      menuDisabled: true,
      summaryType: 'sum',
      getEditor: function (record) {
        if (Ext.isEmpty(record.get('Task'))) {
          return false;
        }
        let minValue = 0;
        return Ext.create('Ext.grid.CellEditor', {
          field: Ext.create('Rally.ui.NumberField', {
            xtype: 'rallynumberfield',
            minValue: minValue,
            selectOnFocus: true,
            listeners: {
              change: function (field, new_value) {
                if (Ext.isEmpty(new_value)) {
                  field.setValue(0);
                }
                record.set('ToDo', new_value);
                record.save();
              }
            }
          })
        });
      },
      renderer: function (value, meta) {
        meta.tdCls = 'ts-right-border';
        return value > 0 ? value : '';
      }
    };

    columns.push(todo_config);

    if (!this.pickableColumns) {
      return columns;
    }

    let pickable_by_index = {};
    Ext.Array.each(this.pickableColumns, function (column) {
      pickable_by_index[column.dataIndex] = column;
    });

    return Ext.Array.map(columns, function (column) {
      let pickable = pickable_by_index[column.dataIndex];
      if (Ext.isEmpty(pickable)) {
        return column;
      }

      if (pickable.hidden) {
        column.hidden = true;
      } else {
        column.hidden = false;
      }
      return column;
    });
  },

  _getBaseLeftColumns: function () {
    let me = this;

    let columns = [
      {
        xtype: 'rallyrowactioncolumn',
        sortable: false,
        scope: me,
        rowActionsFn: function (record) {
          return me._getRowActions(record);
        }
      },
      {
        text: ' ',
        width: 25,
        dataIndex: '__SecretKey',
        renderer: function (value, meta, record) {
          let icons = '';

          if (record.hasOpenDetails()) {
            icons = icons + "<span class='icon-calendar'></span>";
          }
          return icons;
        }
      }
    ];

    return columns;
  },

  _getBaseRightColumns: function () {
    let columns = [];

    Ext.Array.each(
      CA.techservices.timesheet.TimeRowUtils.getOrderedDaysBasedOnWeekStart(this.weekStart),
      function (day, idx) {
        columns.push(this._getColumnForDay(day, idx));
      },
      this
    );

    let total_renderer = function (value, meta) {
      meta.tdCls = 'ts-total-cell';
      return value;
    };

    columns.push({
      dataIndex: 'Total',
      text: 'Total',
      width: 50,
      resizable: false,
      align: 'center',
      editor: null,
      summaryType: 'sum',
      renderer: total_renderer
    });

    return columns;
  },

  _getItemOIDFromRow: function (record) {
    let record_item = record.get('Task') || record.get('WorkProduct');
    let oid = record_item.ObjectID;
    return oid;
  },

  _unpinRecord: function (record) {
    record.set('Pinned', false);
    let oid = this._getItemOIDFromRow(record);
    let key = Ext.String.format('{0}.{1}', this.pinKey, oid);

    let settings = {};
    let value = {};
    value[oid] = false;

    settings[key] = Ext.JSON.encode(value);

    Rally.data.PreferenceManager.update({
      user: Rally.getApp().getContext().getUser().ObjectID,
      filterByUser: true,
      settings: settings
    });
  },

  _pinRecord: function (record) {
    record.set('Pinned', true);
    let record_item = record.get('Task') || record.get('WorkProduct');
    let oid = this._getItemOIDFromRow(record);
    let key = Ext.String.format('{0}.{1}', this.pinKey, oid);

    let settings = {};
    let value = {};
    value[oid] = record_item._type;

    settings[key] = Ext.JSON.encode(value);

    Rally.data.PreferenceManager.update({
      user: Rally.getApp().getContext().getUser().ObjectID,
      filterByUser: true,
      settings: settings
    });
  },

  _getColumnForDay: function (day, idx) {
    let disabled = false;
    let today = new Date();
    let end_date = Ext.Date.add(this.startDate, Ext.Date.DAY, 7);
    let indexToday = today.getDay();
    let weekdays = CA.techservices.timesheet.TimeRowUtils.getOrderedDaysBasedOnWeekStart(0);

    let editor_config = function (record) {
      let minValue = 0;
      return Ext.create('Ext.grid.CellEditor', {
        field: Ext.create('Rally.ui.NumberField', {
          xtype: 'rallynumberfield',
          minValue: minValue,
          maxValue: 36,
          disabled: disabled,
          selectOnFocus: true
        }),
        listeners: {
          complete: function (field, new_value) {
            if (Ext.isEmpty(new_value)) {
              new_value = 0;
              field.setValue(new_value);
            }
            record.set(day, new_value);
            record.save();
          }
        }
      });
    };

    let moment_utc_start = moment(this.startDate).utc();
    let moment_utc_days_later = moment_utc_start.add(idx, 'day').utc();

    let header_text = Ext.String.format('{0}<br/>{1}', CA.techservices.timesheet.TimeRowUtils.dayShortNames[day], moment_utc_days_later.format('D MMM'));

    let config = {
      dataIndex: day,
      html: header_text,
      width: 50,
      resizable: false,
      sortable: true,
      align: 'center',
      getEditor: editor_config,
      field: 'test',
      summaryType: 'sum',
      renderer: function (value) {
        if (value === 0) {
          return '';
        }
        return value;
      },
      summaryRenderer: function (value) {
        if (value === 0) {
          return '';
        }
        return Ext.util.Format.number(value, '0.00');
      }
    };

    //Highlight today
    if (day === weekdays[indexToday] && this.startDate < today && today < end_date) {
      config.renderer = function (value, meta) {
        meta.tdCls = 'ts-total-cell';
        if (value === 0) {
          return '';
        }
        return value;
      };
    }

    if (day === 'Saturday' || day === 'Sunday') {
      config.renderer = function (value, meta) {
        meta.tdCls = 'ts-weekend-cell';
        if (value === 0) {
          return '';
        }
        return value;
      };
    }

    return config;
  },

  _getTimeEntryItemSets: function (time_entry_items) {
    let time_entry_item_sets = {};
    Ext.Array.each(time_entry_items, function (item) {
      let oid = item.get('Task') && item.get('Task').ObjectID;
      if (Ext.isEmpty(oid)) {
        oid = item.get('WorkProduct') && item.get('WorkProduct').ObjectID;
      }
      if (Ext.isEmpty(oid)) {
        oid = item.get('Project') && item.get('Project').ObjectID;
      }

      if (Ext.isEmpty(time_entry_item_sets[oid])) {
        time_entry_item_sets[oid] = [];
      }
      time_entry_item_sets[oid].push(item);
    });

    return Ext.Object.getValues(time_entry_item_sets);
  },

  _createRows: function (time_entry_items, time_entry_values, time_detail_prefs) {
    let rows = [],
      me = this;
    // in Rally, a time row has to start on Sunday, so we'll have up to two
    // time entry items for every row if the week starts on a different day
    let time_entry_item_sets = this._getTimeEntryItemSets(time_entry_items);

    Ext.Array.each(time_entry_item_sets, function (item_set) {
      let item_values = [];

      Ext.Array.each(item_set, function (time_entry_item) {
        let oid = time_entry_item.get('ObjectID');
        let values_for_time_entry_item = Ext.Array.filter(time_entry_values, function (time_entry_value) {
          return time_entry_value.get('TimeEntryItem').ObjectID == oid;
        });

        item_values = Ext.Array.push(item_values, values_for_time_entry_item);
      });

      let item_oid = CA.techservices.timesheet.TimeRowUtils.getItemOIDFromTimeEntryItem(item_set[0]);
      let detail_preference = null;
      Ext.Array.each(time_detail_prefs, function (pref) {
        let name_array = pref.get('Name').split('.');
        if ('' + item_oid == name_array[name_array.length - 1]) {
          detail_preference = pref;
        }
      });

      // switch to Feature instead of PI (so it's not just direct kids)
      if (!Ext.isEmpty(me.lowestLevelPIName)) {
        Ext.Object.each(item_set, function (key, item) {
          if (item.get('WorkProduct') && item.get('WorkProduct')[me.lowestLevelPIName]) {
            let workproduct = item.get('WorkProduct');
            workproduct.PortfolioItem = item.get('WorkProduct')[me.lowestLevelPIName];
            item.set('WorkProduct', workproduct);
          }
        });
      }

      let config = {
        WeekStartDate: me.startDate,
        TimeEntryItemRecords: item_set,
        TimeEntryValueRecords: item_values
      };

      if (!Ext.isEmpty(detail_preference)) {
        config.DetailPreference = detail_preference;
      }
      if (me.time_entry_defaults[item_oid] && me.time_entry_defaults[item_oid] !== false) {
        config.Pinned = true;
      }

      let row = Ext.create('CA.techservices.timesheet.TimeRow', config);
      rows.push(row);
    });

    return rows;
  },

  addRowForItem: function (item) {
    let me = this;

    if (this._hasRowForItem(item)) {
      return;
    }

    let item_type = item.get('_type');
    let sunday_start = TSDateUtils.getBeginningOfWeekISOForLocalDate(me.startDate);

    let config = {
      WorkProduct: {
        _ref: item.get('_ref')
      },
      WeekStartDate: sunday_start,
      User: {
        _ref: '/usr/' + this.timesheetUser.ObjectID
      }
    };

    if (item.get('Project')) {
      config.Project = item.get('Project');
    }

    if (item_type === 'task') {
      config.Task = { _ref: item.get('_ref') };
      config.WorkProduct = { _ref: item.get('WorkProduct')._ref };
    }
    Rally.data.ModelFactory.getModel({
      type: 'TimeEntryItem',
      scope: this,
      success: function (model) {
        let tei = Ext.create(model, config);
        tei.save({
          fetch: me.time_entry_item_fetch,
          callback: function (result) {
            let row = Ext.create('CA.techservices.timesheet.TimeRow', {
              WeekStartDate: me.startDate,
              TimeEntryItemRecords: [result],
              TimeEntryValueRecords: []
            });

            let item_oid = me._getItemOIDFromRow(row);
            if (me.time_entry_defaults[item_oid] && me.time_entry_defaults[item_oid] !== false) {
              row.set('Pinned', true);
            }
            me.grid.getStore().loadRecords([row], { addRecords: true });
            me.rows.push(row);
            me.grid.refresh();
          }
        });
      }
    });
  },

  getGrid: function () {
    return this.grid;
  },

  _hasRowForItem: function (item) {
    let rows = this.rows;
    let hasRow = false;
    let item_type = item.get('_type');

    Ext.Array.each(rows, function (row) {
      if (row) {
        if (item_type === 'task') {
          if (row.get('Task') && row.get('Task')._ref === item.get('_ref')) {
            hasRow = true;
          }
        } else {
          if (Ext.isEmpty(row.get('Task')) && row.get('WorkProduct') && row.get('WorkProduct')._ref === item.get('_ref')) {
            hasRow = true;
          }
        }
      }
    });

    return hasRow;
  },

  _launchTimeDetailsDialog: function (row) {
    Ext.create('CA.technicalservices.TimeDetailsDialog', {
      row: row
    });
  },

  _loadTimeEntryItems: function () {
    this.setLoading('Loading time entry items...');

    let filters = [{ property: 'User.ObjectID', value: this.timesheetUser.ObjectID }];

    if (this.weekStart === 0) {
      filters.push({ property: 'WeekStartDate', value: this.startDate });
    } else {
      filters.push({ property: 'WeekStartDate', operator: '>=', value: Rally.util.DateTime.add(this.startDate, 'day', -6) });
      filters.push({ property: 'WeekStartDate', operator: '<=', value: Rally.util.DateTime.add(this.startDate, 'day', 6) });
    }
    let config = {
      model: 'TimeEntryItem',
      context: {
        project: null
      },
      fetch: this.time_entry_item_fetch,
      enableRankFieldParameterAutoMapping: false,
      filters: filters,
      sorters: [{ property: 'ProjectDisplayString', direction: 'ASC' }],
      limit: this.maxRows * 2,
      pageSize: this.maxRows * 2
    };

    return TSUtilities.loadWsapiRecords(config);
  },

  _loadTimeEntryValues: function () {
    this.setLoading('Loading time entry values...');

    let filters = [{ property: 'TimeEntryItem.User.ObjectID', value: this.timesheetUser.ObjectID }];

    if (this.weekStart === 0) {
      filters.push({ property: 'TimeEntryItem.WeekStartDate', value: this.startDate });
    } else {
      filters.push({ property: 'TimeEntryItem.WeekStartDate', operator: '>=', value: Rally.util.DateTime.add(this.startDate, 'day', -6) });
      filters.push({ property: 'TimeEntryItem.WeekStartDate', operator: '<=', value: Rally.util.DateTime.add(this.startDate, 'day', 6) });
    }

    let config = {
      model: 'TimeEntryValue',
      context: {
        project: null
      },
      fetch: ['DateVal', 'Hours', 'TimeEntryItem', 'ObjectID'],
      filters: filters,
      pageSize: 2000,
      limit: 'Infinity'
    };

    return TSUtilities.loadWsapiRecords(config);
  },

  _loadTimeDetailPreferences: function () {
    this.setLoading('Loading time entry details...');

    let filters = [{ property: 'Name', operator: 'contains', value: CA.techservices.timesheet.TimeRowUtils.getDetailPrefix(this.startDate) }];

    let config = {
      model: 'Preference',
      fetch: ['Name', 'Value'],
      filters: filters,
      context: {
        project: null
      }
    };

    return TSUtilities.loadWsapiRecords(config);
  }
});

                Ext.define('TSTimesheet', {
  extend: 'Rally.app.App',
  componentCls: 'app',
  defaults: { margin: 10 },
  layout: 'border',

  items: [{ xtype: 'container', itemId: 'selector_box', region: 'north', layout: { type: 'hbox' }, minHeight: 25 }],

  pickableColumns: null,
  sortedColumn: null,
  direction: '',
  portfolioItemTypes: [],
  stateful: true,
  stateEvents: ['columnschosen', 'columnmoved', 'columnresize', 'sortchange'],
  stateId: 'CA.technicalservices.timesheet.Settings.4',

  config: {
    defaultSettings: {
      /* 0=sunday, 6=saturday */
      weekStartsOn: 0,
      showAddMyStoriesButton: false,
      showEditTimeDetailsMenuItem: false,
      showTaskStateFilter: false
    }
  },

  async launch() {
    try {
      this.isTimeSheetAdmin = await TSUtilities.getCurrentUserIsTimeSheetAdmin();
      this.portfolioItemTypes = await TSUtilities.fetchPortfolioItemTypes();
      this._addSelectors(this.down('#selector_box'));
    } catch (e) {
      this.showError(e, 'Problem Initiating TimeSheet App');
    }
  },

  _getLowestLevelPIName: function () {
    return this.portfolioItemTypes[0].get('Name');
  },

  _addSelectors: function (container) {
    container.removeAll();
    container.add({ xtype: 'container', itemId: 'add_button_box' });

    const adminContainer = container.add({ xtype: 'container', flex: 1, layout: { type: 'hbox', align: 'middle', pack: 'center' } });
    let week_starts_on = this.getSetting('weekStartsOn');

    if (this.isTimeSheetAdmin()) {
      adminContainer.add({
        xtype: 'rallyusersearchcombobox',
        includeWorkspaceUsers: true,
        context: this.getContext(),
        fieldLabel: 'Select user',
        labelWidth: 65,
        width: 275,
        itemId: 'userCombo',
        id: 'userCombo',
        margin: '0 10 0 10',
        listeners: {
          change() {
            this.updateData();
          },
          scope: this
        }
      });
    }

    container
      .add({
        xtype: 'tsarroweddate',
        itemId: 'date_selector',
        fieldLabel: 'Week Starting',
        listeners: {
          scope: this,
          change: function (dp, new_value) {
            if (Ext.isEmpty(new_value)) {
              return;
            }

            let week_start = TSDateUtils.getBeginningOfWeekForLocalDate(new_value, week_starts_on);
            if (week_start !== new_value) {
              dp.setValue(week_start);
            }
            if (new_value.getDay() === week_starts_on) {
              this.updateData();
            }
          }
        }
      })
      .setValue(new Date());
  },

  _addAddButtons: function (container) {
    container.removeAll();

    container.add({
      xtype: 'rallybutton',
      text: 'Add My Tasks',
      toolTipText: '(in current iteration + defaults)',
      padding: 2,
      disabled: false,
      listeners: {
        scope: this,
        click: this._addCurrentTasksAndDefaults
      }
    });

    if (this.getSetting('showAddMyStoriesButton')) {
      container.add({
        xtype: 'rallybutton',
        text: '+ my <span class="icon-story"> </span>',
        toolTipText: 'Add my stories and stories with my tasks',
        disabled: false,
        listeners: {
          scope: this,
          click: this._addCurrentStories
        }
      });
    }

    container.add({
      xtype: 'rallybutton',
      text: '+<span class="icon-task"> </span>',
      disabled: false,
      toolTipText: 'Search and add Tasks',
      listeners: {
        scope: this,
        click: this._findAndAddTask
      }
    });

    container.add({
      xtype: 'rallybutton',
      text: '+<span class="icon-story"> </span>',
      toolTipText: 'Search and add User Stories',
      disabled: false,
      listeners: {
        scope: this,
        click: this._findAndAddStory
      }
    });

    if (this.getSetting('showTaskStateFilter')) {
      container.add({
        xtype: 'rallyfieldvaluecombobox',
        model: 'Task',
        field: 'State',
        fieldLabel: 'State:',
        labelAlign: 'right',
        stateful: true,
        stateId: 'task-state-filter-combo',
        multiSelect: true,
        value: ['Defined', 'In-Progress', 'Completed'],
        listeners: {
          scope: this,
          change: this._filterState
        }
      });
    }
  },

  _filterState: function (stateChange) {
    let timetable = this.down('tstimetable');

    let stateFilter = new Ext.util.Filter({
      filterFn: function (item) {
        return Ext.Array.contains(stateChange.value, item.get('State')) || !item.get('State');
      }
    });

    if (stateChange.value.length > 0) {
      timetable.grid.filter(stateFilter);
    } else {
      timetable.grid.filter(null, true);
    }
  },

  // my workproducts are stories I own and stories that have tasks I own
  _addCurrentStories: function () {
    let timetable = this.down('tstimetable');

    if (!timetable) {
      return;
    }

    this.setLoading('Finding my current stories...');

    let my_filters = Rally.data.wsapi.Filter.or([
      { property: 'Owner.ObjectID', value: this.getContext().getUser().ObjectID },
      { property: 'Tasks.Owner.ObjectID', value: this.getContext().getUser().ObjectID }
    ]);

    let current_filters = Rally.data.wsapi.Filter.and([
      { property: 'Iteration.StartDate', operator: '<=', value: Rally.util.DateTime.toIsoString(this.startDate) },
      { property: 'Iteration.EndDate', operator: '>=', value: Rally.util.DateTime.toIsoString(this.startDate) }
    ]);

    let config = {
      model: 'HierarchicalRequirement',
      context: {
        project: null
      },
      fetch: ['ObjectID', 'Name', 'FormattedID', 'WorkProduct', 'Project'],
      filters: current_filters.and(my_filters)
    };

    TSUtilities.loadWsapiRecords(config).then({
      scope: this,
      success: function (items) {
        let new_item_count = items.length;
        let current_count = timetable.getGrid().getStore().getTotalCount();

        if (current_count + new_item_count > this.getSetting('maxRows')) {
          Ext.Msg.alert('Problem Adding Items', 'Cannot add items to grid. Limit is ' + this.getSetting('maxRows') + ' lines in the time sheet.');
          this.setLoading(false);
        } else {
          Ext.Array.each(items, function (item) {
            timetable.addRowForItem(item);
          });
        }

        this.setLoading(false);
      },
      failure: function (msg) {
        Ext.Msg.alert('Problem with my stories', msg);
      }
    });
  },

  _addCurrentTasksAndDefaults: function () {
    let me = this;

    Deft.Chain.sequence([this._addCurrentTasks, this._addDefaults], this)
      .then({
        failure: function (msg) {
          Ext.Alert.msg('Problem adding current items', msg);
        }
      })
      .always(function () {
        me.setLoading(false);
      });
  },

  _addDefaults: function () {
    let timetable = this.down('tstimetable'),
      me = this;
    if (!timetable) {
      return;
    }

    let defaults = timetable.time_entry_defaults;

    let promises = [];
    this.setLoading('Finding my defaults...');

    Ext.Object.each(defaults, function (oid, type) {
      if (!type) {
        return;
      }

      promises.push(function () {
        let deferred = Ext.create('Deft.Deferred');

        let config = {
          model: type,
          context: {
            project: null
          },
          fetch: ['ObjectID', 'Name', 'FormattedID', 'WorkProduct', 'Project'],
          filters: [{ property: 'ObjectID', value: oid }]
        };

        TSUtilities.loadWsapiRecords(config).then({
          scope: this,
          success: function (items) {
            let new_item_count = items.length;
            let current_count = timetable.getGrid().getStore().getTotalCount();

            if (current_count + new_item_count > me.getSetting('maxRows')) {
              Ext.Msg.alert('Problem Adding Items', 'Cannot add items to grid. Limit is ' + me.getSetting('maxRows') + ' lines in the time sheet.');
              me.setLoading(false);
            } else {
              Ext.Array.each(items, function (task) {
                timetable.addRowForItem(task);
              });
            }

            me.setLoading(false);
            deferred.resolve(items);
          },
          failure: function (msg) {
            deferred.reject(msg);
          }
        });

        return deferred.promise;
      });
    });

    return Deft.Chain.sequence(promises);
  },

  _addCurrentTasks: function () {
    let me = this;
    let deferred = Ext.create('Deft.Deferred');

    let timetable = this.down('tstimetable');
    if (!timetable) {
      return;
    }

    this.setLoading('Finding my current tasks...');

    let config = {
      model: 'Task',
      context: {
        project: null
      },
      fetch: ['ObjectID', 'Name', 'FormattedID', 'WorkProduct', 'Project'],
      filters: [
        { property: 'Owner.ObjectID', value: this.getContext().getUser().ObjectID },
        { property: 'Iteration.StartDate', operator: '<=', value: Rally.util.DateTime.toIsoString(this.startDate) },
        { property: 'Iteration.EndDate', operator: '>=', value: Rally.util.DateTime.toIsoString(this.startDate) },
        { property: 'State', operator: '!=', value: 'Completed' }
      ]
    };

    TSUtilities.loadWsapiRecords(config).then({
      scope: this,
      success: function (tasks) {
        let new_item_count = tasks.length;
        let current_count = timetable.getGrid().getStore().getTotalCount();

        if (current_count + new_item_count > me.getSetting('maxRows')) {
          Ext.Msg.alert('Problem Adding Items', 'Cannot add items to grid. Limit is ' + me.getSetting('maxRows') + ' lines in the time sheet.');
          this.setLoading(false);
        } else {
          Ext.Array.each(tasks, function (task) {
            timetable.addRowForItem(task);
          });
        }

        this.setLoading(false);
        deferred.resolve(tasks);
      },
      failure: function (msg) {
        deferred.reject(msg);
      }
    });

    return deferred.promise;
  },

  _findAndAddTask: function () {
    let me = this;
    let timetable = this.down('tstimetable');
    let filters = [{ property: 'State', operator: '!=', value: 'Completed' }];
    let fetch_fields = ['WorkProduct', 'Feature', 'Project', 'Name', 'FormattedID', 'ObjectID'];

    if (timetable) {
      Ext.create('Rally.technicalservices.ChooserDialog', {
        artifactTypes: ['task'],
        autoShow: true,
        multiple: true,
        width: 1500,
        title: 'Choose Task(s)',
        context: {
          project: null
        },
        storeConfig: {
          filters: filters
        },
        filterableFields: [
          {
            displayName: 'Formatted ID',
            attributeName: 'FormattedID'
          },
          {
            displayName: 'Name',
            attributeName: 'Name'
          },
          {
            displayName: 'WorkProduct',
            attributeName: 'WorkProduct.Name'
          },
          {
            displayName: 'Project',
            attributeName: 'Project.Name'
          },
          {
            displayName: 'Owner',
            attributeName: 'Owner'
          },
          {
            displayName: 'State',
            attributeName: 'State'
          }
        ],
        columns: [
          {
            text: 'ID',
            dataIndex: 'FormattedID'
          },
          'Name',
          'WorkProduct',
          'Iteration',
          'Release',
          'Project',
          'Owner',
          'State'
        ],
        fetchFields: fetch_fields,
        listeners: {
          artifactchosen: function (dialog, selectedRecords) {
            if (!Ext.isArray(selectedRecords)) {
              selectedRecords = [selectedRecords];
            }

            let new_item_count = selectedRecords.length;
            let current_count = timetable.getGrid().getStore().getTotalCount();

            if (current_count + new_item_count > me.getSetting('maxRows')) {
              Ext.Msg.alert('Problem Adding Tasks', 'Cannot add items to grid. Limit is ' + me.getSetting('maxRows') + ' lines in the time sheet.');
            } else {
              Ext.Array.each(selectedRecords, function (selectedRecord) {
                timetable.addRowForItem(selectedRecord);
              });
            }
          },
          scope: this
        }
      });
    }
  },

  _findAndAddStory: function () {
    let me = this;
    let timetable = this.down('tstimetable');
    let filters = Ext.create('Rally.data.QueryFilter', { property: 'ScheduleState', operator: '=', value: 'Requested' });
    filters = filters.or({ property: 'ScheduleState', operator: '=', value: 'Defined' });
    filters = filters.or({ property: 'ScheduleState', operator: '=', value: 'In-Progress' });
    filters = filters.and({ property: 'DirectChildrenCount', operator: '=', value: 0 });
    filters.toString();

    if (timetable) {
      Ext.create('Rally.technicalservices.ChooserDialog', {
        artifactTypes: ['hierarchicalrequirement', 'defect'],
        autoShow: true,
        title: 'Choose Work Product(s)',
        multiple: true,
        width: 1500,
        storeConfig: {
          filters: filters
        },
        filterableFields: [
          {
            displayName: 'Formatted ID',
            attributeName: 'FormattedID'
          },
          {
            displayName: 'Name',
            attributeName: 'Name'
          },
          {
            displayName: 'Project',
            attributeName: 'Project.Name'
          },
          {
            displayName: 'Owner',
            attributeName: 'Owner'
          }
        ],
        columns: [
          {
            text: 'ID',
            dataIndex: 'FormattedID'
          },
          'Name',
          'Release',
          'Iteration',
          'Project',
          'Owner',
          'ScheduleState'
        ],

        fetchFields: ['WorkProduct', 'Feature', 'Project', 'Name', 'FormattedID', 'ObjectID', 'Release', 'ReleaseDate'],

        listeners: {
          artifactchosen: function (dialog, selectedRecords) {
            if (!Ext.isArray(selectedRecords)) {
              selectedRecords = [selectedRecords];
            }

            let new_item_count = selectedRecords.length;
            let current_count = timetable.getGrid().getStore().getTotalCount();

            if (current_count + new_item_count > me.getSetting('maxRows')) {
              Ext.Msg.alert('Problem Adding Stories', 'Cannot add items to grid. Limit is ' + me.getSetting('maxRows') + ' lines in the time sheet.');
            } else {
              Ext.Array.each(selectedRecords, function (selectedRecord) {
                if (selectedRecord.get('Release') && new Date(selectedRecord.get('Release').ReleaseDate) < new Date() && !me.isTimeSheetAdmin()) {
                  me.showError(`${selectedRecord.get('FormattedID')} is in a past Release. Time cannot be charged against it`);
                } else {
                  timetable.addRowForItem(selectedRecord);
                }
              });
            }
          },
          scope: this
        }
      });
    }
  },

  updateData: function () {
    let timesheetUser;
    let timetable = this.down('tstimetable');

    if (!Ext.isEmpty(timetable)) {
      timetable.destroy();
    }

    if (this.down('#userCombo') && this.down('#userCombo').getRecord()) {
      timesheetUser = this.down('#userCombo').getRecord().getData();
    }

    this.startDate = this.down('#date_selector').getValue();

    let editable = true;

    this.time_table = this.add({
      xtype: 'tstimetable',
      region: 'center',
      layout: 'fit',
      margin: 15,
      timesheetUser,
      pickableColumns: this.pickableColumns,
      sortedColumn: this.sortedColumn,
      sortDirection: this.sortDirection,
      lowestLevelPIName: this._getLowestLevelPIName(),
      startDate: this.startDate,
      editable: editable,
      maxRows: this.getSetting('maxRows'),
      showEditTimeDetailsMenuItem: this.getSetting('showEditTimeDetailsMenuItem'),
      listeners: {
        scope: this,
        gridReady: function () {
          this._addAddButtons(this.down('#add_button_box'));
        },
        sortchange: function (grid, dataIndex, direction) {
          this.sortedColumn = dataIndex;
          this.sortDirection = direction;
          this.fireEvent('sortchange', this, dataIndex, direction);
        }
      }
    });
  },

  isTimeSheetAdmin() {
    return this.isTimeSheetAdmin;
  },

  getSettingsFields: function () {
    let check_box_margins = '5 0 5 0';

    let days_of_week = [
      { Name: 'Sunday', Value: 0 },
      { Name: 'Monday', Value: 1 },
      { Name: 'Tuesday', Value: 2 },
      { Name: 'Wednesday', Value: 3 },
      { Name: 'Thursday', Value: 4 },
      { Name: 'Friday', Value: 5 },
      { Name: 'Saturday', Value: 6 }
    ];

    return [
      {
        name: 'weekStartsOn',
        xtype: 'rallycombobox',
        fieldLabel: 'Week Starts On',
        labelWidth: 100,
        labelAlign: 'left',
        minWidth: 200,
        displayField: 'Name',
        valueField: 'Value',
        value: this.getSetting('weekStartsOn'),
        store: Ext.create('Rally.data.custom.Store', {
          data: days_of_week
        }),

        readyEvent: 'ready'
      },
      {
        name: 'showTaskStateFilter',
        xtype: 'rallycheckboxfield',
        boxLabelAlign: 'after',
        fieldLabel: '',
        margin: check_box_margins,
        boxLabel: 'Show the Task State Filter<br/><span style="color:#999999;"><i>User can limit display of tasks to ones in particular states (does not affect other object types).</i></span>'
      },
      {
        name: 'showAddMyStoriesButton',
        xtype: 'rallycheckboxfield',
        boxLabelAlign: 'after',
        fieldLabel: '',
        margin: check_box_margins,
        boxLabel:
          'Show the Add My Stories Button<br/><span style="color:#999999;"><i>User can add stories in a current sprint that they own or that have tasks they own (does not look for default items).</i></span>'
      },
      {
        name: 'showEditTimeDetailsMenuItem',
        xtype: 'rallycheckboxfield',
        boxLabelAlign: 'after',
        fieldLabel: '',
        margin: check_box_margins,
        boxLabel: 'Include Time Details Option in Menu (Experimental)<br/><span style="color:#999999;"><i>User can enter time ranges during the day to calculate time entry. </i></span>'
      },
      {
        xtype: 'rallynumberfield',
        name: 'maxRows',
        labelWidth: 100,
        labelAlign: 'left',
        width: 200,
        maxValue: 1000,
        minValue: 10,
        fieldLabel: 'Maximum number of rows',
        value: this.getSetting('maxRows') || 100
      }
    ];
  },

  getState: function () {
    return {
      pickableColumns: this.pickableColumns,
      sortedColumn: this.sortedColumn,
      sortDirection: this.sortDirection
    };
  },

  isExternal: function () {
    return typeof this.getAppId() == 'undefined';
  },

  onSettingsUpdate: function () {
    this.launch();
  },

  showError(msg, defaultMessage) {
    Rally.ui.notify.Notifier.showError({ message: this.parseError(msg, defaultMessage) });
  },

  parseError(e, defaultMessage) {
    defaultMessage = defaultMessage || 'An unknown error has occurred';

    if (typeof e === 'string' && e.length) {
      return e;
    }
    if (e.message && e.message.length) {
      return e.message;
    }
    if (e.exception && e.error && e.error.errors && e.error.errors.length) {
      if (e.error.errors[0].length) {
        return e.error.errors[0];
      }
      if (e.error && e.error.response && e.error.response.status) {
        return `${defaultMessage} (Status ${e.error.response.status})`;
      }
    }
    if (e.exceptions && e.exceptions.length && e.exceptions[0].error) {
      return e.exceptions[0].error.statusText;
    }
    if (e.exception && e.error && typeof e.error.statusText === 'string' && !e.error.statusText.length && e.error.status && e.error.status === 524) {
      return 'The server request has timed out';
    }
    return defaultMessage;
  }
});


            Rally.launchApp('TSTimesheet', {
                name:"Rally Enhanced Timesheet",
                parentRepos:"",
                version:"0.1.3"
            });

        });
    </script>



    <style type="text/css">
        .x-btn-tsnav-small {
  background-image: none;
  background-color: white;
  border-color: white !important;
  text-decoration: none;
}
.no-border {
  border-style: none;
  color: red !important;
  background-color: white !important ;
}
.no-border .x-btn-inner {
  color: red !important;
  background-color: white !important ;
}
td.ts-total-cell {
  background-color: #eee !important;
}
.x-grid-row-summary {
  background-color: #eee;
}
.x-grid-row-alt .x-grid-td {
  background-color: #fff;
}
.x-border-layout-ct {
  background-color: #ffffff;
}
td.ts-weekend-cell {
  background-color: #B0E0E6 !important;
}
span.red {
  color: red;
}
td.ts-right-border {
  border-style: solid;
  border-right: thick double #aaa;
}

    </style>
</head>
<body>
</body>
</html>
